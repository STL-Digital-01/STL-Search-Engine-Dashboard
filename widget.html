<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Custom Search UI</title>
  <link rel="stylesheet" href="style.css">
  <link rel="stylesheet" href="background.css">

  <style>
    body {
      margin: 0;
      padding: 0;
      font-family: 'Segoe UI', sans-serif;
      height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      /* Center horizontally */
      background: linear-gradient(135deg, #6a11cb 0%, #2575fc 100%);
    }

    /* Top area */
    .top-bar {
      width:100%;
      padding:34px 20px 10px;
      display:flex;
      justify-content:center;
      box-sizing:border-box;
      position:sticky;
      top:0;
      z-index:50;
      background:linear-gradient(135deg,#6a11cb 0%,#2575fc 100%);
    }

    .search-shell {
      width:100%;
      max-width:800px;
      background:#fff;
      display:flex;
      align-items:center;
      gap:10px;
      padding:10px 16px;
      border-radius:999px;
      border:1px solid #e2e8f0;
      box-shadow:0 4px 16px rgba(0,0,0,.12);
      transition:box-shadow .25s,border-color .25s;
    }
    .search-shell:focus-within { box-shadow:0 6px 22px rgba(0,0,0,.18); border-color:#bfdbfe; }
    .search-shell input { flex:1; border:none; outline:none; font-size:16px; background:transparent; font-family:inherit; }
    .icon-btn { background:#2575fc; color:#fff; border:none; padding:10px 22px; border-radius:24px; font-size:15px; cursor:pointer; display:flex; align-items:center; gap:6px; box-shadow:0 2px 6px rgba(0,0,0,.25); transition:background .25s, transform .15s; }
    .icon-btn:disabled { background:#9ca3af; cursor:not-allowed; box-shadow:none; }
    .icon-btn:not(:disabled):hover { background:#1d60cc; }
    .icon-btn:not(:disabled):active { transform:translateY(1px); }

    .page-wrapper { width:100%; display:flex; flex-direction:column; align-items:center; }
    .answer-wrapper { width:100%; max-width:900px; padding:0 20px 80px; box-sizing:border-box; }
    .status-line { margin:10px 0 18px; font-size:12px; font-family:monospace; color:#ffe08a; }

    .answer-card { background:#ffffff; border-radius:18px; padding:22px 26px 28px; box-shadow:0 4px 22px -4px rgba(0,0,0,.25); line-height:1.55; font-size:15px; position:relative; overflow:hidden;  margin-top: 10rem;}
    .answer-card h3 { margin:0 0 14px; font-size:14px; text-transform:uppercase; letter-spacing:1px; color:#475569; font-weight:600; }
    .faded-label { font-size:11px; text-transform:uppercase; letter-spacing:1px; color:#64748b; font-weight:600; }
    .chips { margin-top:18px; display:flex; flex-wrap:wrap; gap:8px; }
    .chip { background:#2575fc; color:#fff; border:none; padding:6px 12px; border-radius:24px; font-size:12px; cursor:pointer; line-height:1; display:inline-flex; align-items:center; gap:4px; box-shadow:0 2px 6px rgba(0,0,0,.2); }
    .chip:hover { background:#1d60cc; }
  /* citation UI removed */
    .citation-detail { margin-top:10px; background:#f8fafc; border:1px solid #e2e8f0; padding:12px 14px; border-radius:10px; font-size:12px; max-height:220px; overflow:auto; }
    .skeleton { background:linear-gradient(90deg,#f1f5f9 25%,#e2e8f0 37%,#f1f5f9 63%); background-size:400% 100%; animation:shimmer 1.4s ease infinite; border-radius:6px; }
    .sk-line { height:14px; margin:6px 0; }
    @keyframes shimmer { 0% {background-position:100% 0;} 100% {background-position:0 0;} }
    .empty-hint { font-size:13px; color:#e2e8f0; margin-top:40px; text-align:center; }
    .error-text { color:#dc2626; font-weight:500; }
    .badge { position:absolute; top:10px; right:14px; background:#eef2ff; color:#3730a3; font-size:11px; padding:4px 8px; border-radius:14px; font-weight:600; letter-spacing:.5px; }
    .mini { font-size:11px; opacity:.85; }
    .ref-block { margin-bottom:14px; }
    .ref-block pre { white-space:pre-wrap; word-break:break-word; font-size:11px; background:#fff; margin:6px 0 0; padding:8px 10px; border:1px solid #e2e8f0; border-radius:6px; }
  </style>
</head>

<body>
  <div class="page-wrapper">
    <div class="top-bar">
      <div style="width:100%;display:flex;flex-direction:column;align-items:center;gap:10px;">
        <div style="width:100%;max-width:800px;display:flex;align-items:center;justify-content:flex-start;margin-bottom:10px;">
          <label for="engineIdInput" style="font-size:15px;color:#2575fc;font-weight:700;margin-right:10px;">App ID</label>
          <input id="engineIdInput" type="text" value="z-app_1753360472660" style="font-size:15px;padding:8px 16px;border-radius:14px;border:1px solid #e2e8f0;width:260px;background:#fff;color:#2575fc;font-weight:600;outline:none;transition:border-color .2s;box-shadow:0 2px 12px rgba(96,165,250,0.10);" />
        </div>
        <div class="search-shell" id="searchShell">
          <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="#64748b" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="margin-right:10px;"><circle cx="11" cy="11" r="8"/><line x1="21" y1="21" x2="16.65" y2="16.65"/></svg>
          <input id="searchInput" class="modern-search" placeholder="" autocomplete="off" />
          <button id="askBtn" class="icon-btn" disabled>
            <span>Ask</span>
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="22" y1="2" x2="11" y2="13"/><polygon points="22 2 15 22 11 13 2 9 22 2"/></svg>
          </button>
          <div id="tokenInfo" style="display:none;margin:8px 0 0 0;font-size:12px;color:#64748b;background:#f1f5f9;padding:4px 8px;border-radius:4px;max-width:80%;word-break:break-all;"></div>
        </div>
      </div>
    </div>
    <div class="answer-wrapper">
      <div id="tokenStatus" class="status-line">Auth: waiting for login...</div>
      <div id="answerRegion">
        <p class="empty-hint">Start typing a question and press Enter or click Ask.</p>
      </div>
      <div id="relatedQuestions" class="chips"></div>
      <div id="citationsPanel"></div>
    </div>
  </div>

  <script>
    (function(){
      let defaultEngineId = "z-app_1753360472660";
      let engineId = localStorage.getItem('engineId') || defaultEngineId;
      const engineInput = document.getElementById('engineIdInput');
      function getApiUrl() {
        return `https://us-discoveryengine.googleapis.com/v1alpha/projects/19437895168/locations/us/collections/default_collection/engines/${engineId}/servingConfigs/default_search:answer`;
      }
      if(engineInput){
        engineInput.value = engineId;
        engineInput.addEventListener('input', function(){
          engineId = engineInput.value.trim() || defaultEngineId;
          localStorage.setItem('engineId', engineId);
        });
      }
      // NOTE: Do NOT hardcode a bearer token in production. This is only for quick testing.
      let bearerToken = "REPLACE_WITH_RUNTIME_TOKEN"; // placeholder
      // Restore token from localStorage if present
      const storedToken = localStorage.getItem('searchAuthToken');
      if(storedToken && storedToken.length > 20){
        bearerToken = storedToken;
      }
    const tokenInfo = document.getElementById('tokenInfo');
    tokenInfo.textContent = bearerToken && bearerToken !== 'REPLACE_WITH_RUNTIME_TOKEN' ? `Access Token: ${bearerToken}` : 'No access token set.';
      const input = document.getElementById('searchInput');
      const btn = document.getElementById('askBtn');
      const relatedWrap = document.getElementById('relatedQuestions');
      const tokenStatus = document.getElementById('tokenStatus');
      const answerRegion = document.getElementById('answerRegion');
      const citationsPanel = document.getElementById('citationsPanel');

      function setLoading(isLoading){
        if(isLoading){
          btn.disabled = true; btn.classList.add('loading');
          btn.innerHTML = '<span>Loading</span>';
          answerRegion.innerHTML = `
                <div class="answer-card">
                  <span class="badge">Generating</span>
                  <div class="sk-line skeleton" style="width:60%"></div>
                  <div class="sk-line skeleton" style="width:85%"></div>
                  <div class="sk-line skeleton" style="width:78%"></div>
                  <div class="sk-line skeleton" style="width:66%"></div>
                  <div class="sk-line skeleton" style="width:40%"></div>
                </div>`;
        } else {
          btn.disabled = false; btn.classList.remove('loading');
          btn.innerHTML = '<span>Ask</span> <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="22" y1="2" x2="11" y2="13"/><polygon points="22 2 15 22 11 13 2 9 22 2"/></svg>';
        }
      }

      function tokenAvailable(){
        return bearerToken && bearerToken !== 'REPLACE_WITH_RUNTIME_TOKEN' && bearerToken.length > 20;
      }

      function ensureTokenOrWarn(){
        if(!tokenAvailable()){
          answerRegion.innerHTML = '<p class="error-text">You must login first. Token not received.</p>';
          return false;
        }
        return true;
      }

      async function callApi(queryText){
        if(!ensureTokenOrWarn()) return;
        if(!queryText){
          answerRegion.innerHTML = '<p class="error-text">Enter a question.</p>';
          return;
        }
        tokenInfo.textContent = bearerToken && bearerToken !== 'REPLACE_WITH_RUNTIME_TOKEN' ? `Access Token: ${bearerToken}` : 'No access token set.';
        setLoading(true);
        relatedWrap.innerHTML = '';
        citationsPanel.innerHTML = '';
        try {
          const payload = {
            query: { text: queryText, queryId: "" },
            session: "",
            relatedQuestionsSpec: { enable: true },
              answerGenerationSpec: {
              ignoreAdversarialQuery: true,
              ignoreNonAnswerSeekingQuery: false,
              ignoreLowRelevantContent: true,
              multimodalSpec: {},
              // citations removed from payload
              promptSpec: { preamble: "Given the conversation between a user and a helpful assistant and some search results, create a final answer for the assistant. The answer should use all relevant information from the search results, not introduce any additional information, and use exactly the same words as the search results when possible. The assistant's answer should be no more than 50 words. The user is an expert who has an in-depth understanding of the subject matter. The assistant should answer in a technical manner that uses specialized knowledge and terminology when it helps answer the query." },
              modelSpec: { modelVersion: "stable" }
            }
          };

          // Debug: log outgoing payload so we can inspect what's sent to Discovery Engine
          try {
            console.log('Discovery Engine request payload:', JSON.parse(JSON.stringify(payload)));
          } catch (e) { console.log('Payload (string):', String(JSON.stringify(payload))); }

          const res = await fetch(getApiUrl(), {
            method: 'POST',
            headers: {
              'Authorization': 'Bearer ' + bearerToken,
              'Content-Type': 'application/json'
            },
            body: JSON.stringify(payload)
          });

          // Try to parse JSON safely and print status + body for debugging 400/500 errors
          let data;
          try {
            const text = await res.text();
            try { data = JSON.parse(text); }
            catch(_) { data = { _rawText: text }; }
            console.log('Discovery Engine response status:', res.status, res.statusText);
            console.log('Discovery Engine response body:', data);
            if (!res.ok) {
              console.error('Discovery Engine request failed', { status: res.status, body: data });
            }
          } catch (e) {
            console.error('Failed to read Discovery Engine response', e);
          }
          const answerText = data?.answer?.answerText || '';
          // IRR extraction: support comma-separated lists, plain percent values, year-based, labeled IRRs, no duplicates 
          let irrValues = [];
          const seenIRR = new Set();
          // 1. Year-based IRRs: e.g. '0.1514 for 2 years' or '0.1514% (2 years)'
          const irrForYearRegex = /([0-9]+\.[0-9]+%?)\s*for\s*(\d+) years?/gi;
          let forYearMatch;
          while ((forYearMatch = irrForYearRegex.exec(answerText)) !== null) {
            const key = forYearMatch[1] + '_year_' + forYearMatch[2];
            if (!seenIRR.has(key)) {
              irrValues.push({ irr: forYearMatch[1], year: forYearMatch[2], label: `Year ${forYearMatch[2]}`, raw: forYearMatch[0] });
              seenIRR.add(key);
            }
          }
          const irrYearRegex = /([0-9]+\.[0-9]+%?)\s*\((\d+) years?\)/gi;
          let yearMatch;
          while ((yearMatch = irrYearRegex.exec(answerText)) !== null) {
            const key = yearMatch[1];
            if (!seenIRR.has(key)) {
              irrValues.push({ irr: yearMatch[1], year: yearMatch[2], raw: yearMatch[0] });
              seenIRR.add(key);
            }
          }
          // 2. IRR with labels: e.g. '0.1160% (Base IRR)' or '0.XXXX (Project IRR)'
          const irrLabelRegex = /([0-9]+\.[0-9]+%?)\s*\(([^)]+IRR)\)/gi;
          let labelMatch;
          while ((labelMatch = irrLabelRegex.exec(answerText)) !== null) {
            const key = labelMatch[1];
            if (!seenIRR.has(key)) {
              irrValues.push({ irr: labelMatch[1], label: labelMatch[2].trim(), raw: labelMatch[0] });
              seenIRR.add(key);
            }
          }
          // 3. Comma-separated IRR lists: 'It is 0.732..., 0.623..., ...'
          const irrCommaListRegex = /(?:is|are|include|varies\.|values?\s*[:=])\s*([0-9.,\sand%]+)/gi;
          let commaListMatch;
          while ((commaListMatch = irrCommaListRegex.exec(answerText)) !== null) {
            // Replace 'and' with comma, then split
            const cleaned = commaListMatch[1].replace(/\band\b/gi, ',');
            const numbers = cleaned.match(/([0-9]+\.[0-9]+%?|[0-9]+%?)/g);
            if (numbers) {
              numbers.forEach(n => {
                if (!seenIRR.has(n)) {
                  irrValues.push({ irr: n, raw: n });
                  seenIRR.add(n);
                }
              });
            }
          }
          // 4. IRR percent values: '0.1741%', etc. (not associated with years/labels)
          const irrPercentRegex = /([0-9]+\.[0-9]+)\s*%/g;
          let percentMatch;
          while ((percentMatch = irrPercentRegex.exec(answerText)) !== null) {
            const key = percentMatch[0];
            if (!seenIRR.has(key)) {
              irrValues.push({ irr: percentMatch[0], raw: percentMatch[0] });
              seenIRR.add(key);
            }
          }
          // 5. Standalone decimal IRR values (not percent, not year, not label)
          // 6. IRR percent values with year context: '0.1741% over 10 years'
          // 7. Handle IRR values for years 2-10 and prevent duplicate plain values
          const yearIrrs = [];
          const yearIrrRegex = /([0-9]+\.[0-9]+%?)\s*(?:over|for)\s*(\d+) years?/gi;
          let yearIrrMatch;
          while ((yearIrrMatch = yearIrrRegex.exec(answerText)) !== null) {
            const key = yearIrrMatch[1] + '_year_' + yearIrrMatch[2];
            if (!irrValues.some(v => v.irr === yearIrrMatch[1] && v.year == yearIrrMatch[2])) {
              irrValues.push({ irr: yearIrrMatch[1], year: yearIrrMatch[2], label: `Year ${yearIrrMatch[2]}`, raw: yearIrrMatch[0] });
              yearIrrs.push(yearIrrMatch[1]);
            }
          }
          // Remove plain values that match a year IRR
          // Remove plain values that match a year IRR, and prevent duplicate year entries
          irrValues = irrValues.filter((v, i, arr) => {
            // Remove plain value if a year IRR exists for this value
            if (!v.year && yearIrrs.includes(v.irr)) {
              return false;
            }
            // Remove duplicate year entries (same year and value)
            if (v.year) {
              // Only keep the first occurrence of this year/value
              return arr.findIndex(x => x.year === v.year && x.irr === v.irr) === i;
            }
            // Remove duplicate plain values (same value, no year)
            if (!v.year) {
              return arr.findIndex(x => !x.year && x.irr === v.irr) === i;
            }
            return true;
          });
          const irrPercentYearRegex = /([0-9]+\.[0-9]+%)\s*(?:over|for)\s*(\d+) years?/gi;
          let percentYearMatch;
          while ((percentYearMatch = irrPercentYearRegex.exec(answerText)) !== null) {
            const key = percentYearMatch[1] + '_year_' + percentYearMatch[2];
            if (!seenIRR.has(key)) {
              irrValues.push({ irr: percentYearMatch[1], year: percentYearMatch[2], label: `Year ${percentYearMatch[2]}`, raw: percentYearMatch[0] });
              seenIRR.add(key);
            }
          }
          // Match decimal numbers but avoid using lookbehind/behind for compatibility
          const irrDecimalRegex = /([0-9]+\.[0-9]+)/g;
          let decimalMatch;
          while ((decimalMatch = irrDecimalRegex.exec(answerText)) !== null) {
            const key = decimalMatch[1];
            const idx = decimalMatch.index;
            const before = answerText[idx - 1] || '';
            const after = answerText[idx + decimalMatch[0].length] || '';
            // skip if adjacent to a digit or percent sign (to approximate word boundaries used earlier)
            if (/\d|%/.test(before) || /\d|%/.test(after)) continue;
            // Only add if not already captured with year or label
            if (!irrValues.some(v => v.irr === key && (v.year || v.label))) {
              if (!seenIRR.has(key)) {
                irrValues.push({ irr: key, raw: key });
                seenIRR.add(key);
              }
            }
          }
          // Overwrite localStorage with IRR values in answer order, no duplicates
          // Final deduplication: keep only the most specific entry for each IRR value
          const uniqueIRRs = {};
          irrValues.forEach(v => {
            const key = v.irr;
            // Prefer year/label over plain value
            if (!uniqueIRRs[key]) {
              uniqueIRRs[key] = v;
            } else {
              if ((v.year || v.label) && !uniqueIRRs[key].year && !uniqueIRRs[key].label) {
                uniqueIRRs[key] = v;
              }
            }
          });
          // Remove duplicate year entries
          const finalIRRs = Object.values(uniqueIRRs).filter((v, i, arr) => {
            if (v.year) {
              return arr.findIndex(x => x.year === v.year && x.irr === v.irr) === i;
            }
            return true;
          });
          // Persist price breakdowns first (enhanced parsing)
          try {
            // Load existing
            const priceBreakdowns = JSON.parse(localStorage.getItem('priceBreakdowns') || '[]');

            // 1) Plant-named total + calculated components (existing pattern)
            const pricePattern = /For\s+material\s+(\d+),\s*([^\(]+?)\s*\((PL\d+)\)\s*offers the lowest total per-unit cost at\s*\$?([0-9]+\.[0-9]+)/ig;
            let priceMatch;
            while ((priceMatch = pricePattern.exec(answerText)) !== null) {
              const material = priceMatch[1];
              const plantName = priceMatch[2].trim();
              const plantId = priceMatch[3];
              const totalCost = parseFloat(priceMatch[4]);
              const components = [];
              const calcMatch = /calculated as\s*([^\.]*)/i.exec(answerText);
              if (calcMatch && calcMatch[1]) {
                const parts = calcMatch[1].split('+').map(p => p.trim()).filter(Boolean);
                parts.forEach(p => {
                  const labeled = /([A-Za-z0-9 \-\/]+?)\s*\(\$?([0-9]+\.[0-9]+)\)/i.exec(p);
                  if (labeled) components.push({ label: labeled[1].trim(), value: parseFloat(labeled[2]) });
                  else {
                    const valOnly = /\$?([0-9]+\.[0-9]+)/.exec(p);
                    if (valOnly) components.push({ label: valOnly[1], value: parseFloat(valOnly[1]) });
                    else components.push({ label: p, value: null });
                  }
                });
              }
              // sanitize component labels and values (handle cases like 'Vendor Price ($1')
              const sanitizedComponents = components.map(c => {
                let lab = (c.label || '').trim();
                // extract numeric inside parentheses if present and value missing
                if ((c.value === null || c.value === undefined) && /\$?([0-9]+\.[0-9]+)/.test(lab)) {
                  const m = /\$?([0-9]+\.[0-9]+)/.exec(lab);
                  if (m) {
                    c.value = parseFloat(m[1]);
                    // remove the numeric portion and stray parentheses from label
                    lab = lab.replace(/\(?\$?[0-9]+\.[0-9]+\)?/g, '').trim();
                  }
                }
                // clean trailing punctuation
                lab = lab.replace(/[\(\),:\.]+$/g, '').trim();
                const val = (c.value !== null && c.value !== undefined) ? Number(c.value) : null;
                const unit = val !== null ? 'usd' : 'unknown';
                return { label: lab || String(val || ''), value: val, unit, source: 'paired' };
              });

              // avoid pushing duplicates: check for existing entry with same material+plantId+total+components signature
              const compSig = JSON.stringify(sanitizedComponents.map(x => ({label: x.label, value: x.value})));
              const exists = priceBreakdowns.find(pb => pb.material === material && pb.plantId === plantId && Number(pb.totalCost) === Number(totalCost) && JSON.stringify((pb.components||[]).map(x=>({label:x.label,value:x.value}))) === compSig);
              if (!exists) priceBreakdowns.push({ material, plantName, plantId, totalCost, components: sanitizedComponents, timestamp: Date.now() });
            }

            // 2) Component-only per-material sentences, including multi-material lists and raw material cost units (INR/ton)
            // Examples handled:
            // "For material 100001, 100002, and 100003, the production cost is 363.526..."
            // "The Cost Of Production is 34585.5359."
            // "Raw material costs include RSMM rock at 5722.2222 INR/ton and Jordan rock at 8808.2840 INR/ton."
            const materialListPattern = /For\s+material[s]?\s+((?:\d+\s*(?:,|and)?\s*)+),\s*([^\.]*)(?:\.|$)/ig;
            let listMatch;
            while ((listMatch = materialListPattern.exec(answerText)) !== null) {
              const matsRaw = listMatch[1];
              const sentence = listMatch[2];
              const materials = matsRaw.split(/(?:,|\band\b)/i).map(s => s.trim()).filter(Boolean);
              // Known component label patterns (monetary)
              const compRegex = /(production cost|vendor price|transport cost|holding cost|production|vendor|transport|holding|vendor cost|cost of production)\s*(?:is|:|=)?\s*\$?([0-9]+(?:\.[0-9]+)?)/ig;
              const compLabelRegex = /([A-Za-z0-9 \-]{3,60}?)\s*(?:is|:|=)?\s*\$?([0-9]+(?:\.[0-9]+)?)/ig;
              // Raw material INR/ton pattern
              const rawMatRegex = /([A-Za-z0-9 \-]+?)\s+at\s+([0-9]+(?:\.[0-9]+)?)\s*INR\/ton/ig;
              const components = [];
              let foundAny = false;
              let mMatch;
              // first, explicit known labels
              while ((mMatch = compRegex.exec(sentence)) !== null) {
                let rawLabel = (mMatch[1] || 'Component').trim();
                const value = parseFloat(mMatch[2]);
                rawLabel = rawLabel.replace(/^production$/i, 'Production Cost')
                                     .replace(/^vendor$/i, 'Vendor Price')
                                     .replace(/^transport$/i, 'Transport Cost')
                                     .replace(/^holding$/i, 'Holding Cost')
                                     .replace(/vendor cost/i, 'Vendor Price')
                                     .replace(/cost of production/i, 'Cost Of Production');
                components.push({ label: capitalizeLabel(rawLabel), value, unit: 'usd' });
                foundAny = true;
              }
              // next, raw material INR/ton entries
              while ((mMatch = rawMatRegex.exec(sentence)) !== null) {
                const rawLabel = (mMatch[1] || '').trim();
                const value = parseFloat(mMatch[2]);
                if (rawLabel) {
                  components.push({ label: capitalizeLabel(rawLabel), value, unit: 'inr_per_ton' });
                  foundAny = true;
                }
              }
              // fallback generic extraction only if labels present (do not invent labels)
              if (!foundAny) {
                let gMatch;
                while ((gMatch = compLabelRegex.exec(sentence)) !== null) {
                  const rawLabel = (gMatch[1] || '').trim();
                  const val = parseFloat(gMatch[2]);
                  // Only accept if rawLabel appears reasonably like a label (contains letters)
                  if (/[A-Za-z]/.test(rawLabel)) {
                    components.push({ label: capitalizeLabel(rawLabel), value: val, unit: 'usd' });
                    foundAny = true;
                  }
                }
              }
              if (foundAny && components.length) {
                // compute totalCost only if sentence explicitly gives an aggregate or if components can be summed
                const sum = components.reduce((s, c) => s + (c.value || 0), 0);
                const maybeTotal = /(?:total cost|cost of production|total per-unit cost|total cost is)\s*(?:is|:|=)?\s*\$?([0-9]+(?:\.[0-9]+)?)/i.exec(sentence);
                const totalCost = maybeTotal ? parseFloat(maybeTotal[1]) : (sum || null);
                // push an entry per material found
                materials.forEach(material => {
                  const sanitizedComponents = components.map(c => ({ label: (c.label||'').replace(/[\(\),:\.]+$/g,'').trim(), value: (c.value !== null && c.value !== undefined) ? Number(c.value) : null, unit: c.unit || (c.value !== null ? 'usd' : 'unknown'), source: 'paired' }));
                  const compSig = JSON.stringify(sanitizedComponents.map(x => ({label: x.label, value: x.value, unit: x.unit})));
                  const exists = priceBreakdowns.find(pb => pb.material === material && JSON.stringify((pb.components||[]).map(x=>({label:x.label,value:x.value,unit:x.unit}))) === compSig);
                  if (!exists) priceBreakdowns.push({ material, plantName: '', plantId: '', totalCost, components: sanitizedComponents, timestamp: Date.now() });
                });
              }
            }

            // single-material fallback (existing behavior)
            const materialSentencePattern = /For\s+material\s+(\d+),\s*([^\.]*)(?:\.|$)/ig;
            let matMatch;
            while ((matMatch = materialSentencePattern.exec(answerText)) !== null) {
              const material = matMatch[1];
              const sentence = matMatch[2];
              // find all label/value pairs inside the sentence
              // First try explicit known component labels like 'production cost' or 'vendor price'
              const compRegex = /(production cost|vendor price|transport cost|holding cost|production|vendor|transport|holding|vendor cost)\s*(?:is|:|=)?\s*\$?([0-9]+\.[0-9]+)/ig;
              const compLabelRegex = /([A-Za-z ]{3,40}?)\s*(?:is|:|=)?\s*\$?([0-9]+\.[0-9]+)/ig;
              const components = [];
              let foundAny = false;
              let cMatch;
              while ((cMatch = compRegex.exec(sentence)) !== null) {
                let rawLabel = (cMatch[1] || 'Component').trim();
                const value = parseFloat(cMatch[2]);
                // normalize common short forms to canonical labels
                rawLabel = rawLabel.replace(/^production$/i, 'Production Cost')
                                     .replace(/^vendor$/i, 'Vendor Price')
                                     .replace(/^transport$/i, 'Transport Cost')
                                     .replace(/^holding$/i, 'Holding Cost')
                                     .replace(/vendor cost/i, 'Vendor Price');
                components.push({ label: capitalizeLabel(rawLabel), value });
                foundAny = true;
              }
              // fallback generic extraction of "Label $x.xx" pairs
              if (!foundAny) {
                while ((cMatch = compLabelRegex.exec(sentence)) !== null) {
                  const rawLabel = (cMatch[1] || 'Component').trim();
                  const value = parseFloat(cMatch[2]);
                  // only accept if rawLabel contains letters (avoid bare numbers)
                  if (/[A-Za-z]/.test(rawLabel)) {
                    components.push({ label: capitalizeLabel(rawLabel), value });
                    foundAny = true;
                  }
                }
              }
              if (foundAny) {
                const totalCost = components.reduce((s, c) => s + (c.value || 0), 0);
                  // sanitize components similar to above
                  const sanitizedComponents = components.map(c => {
                    const lab = (c.label||'').replace(/[\(\),:\.]+$/g,'').trim() || String(c.value || '');
                    const val = (c.value !== null && c.value !== undefined) ? Number(c.value) : null;
                    const unit = val !== null ? 'usd' : 'unknown';
                    return { label: lab, value: val, unit, source: 'paired' };
                  });
                  const compSig = JSON.stringify(sanitizedComponents.map(x => ({label: x.label, value: x.value})));
                  const exists = priceBreakdowns.find(pb => pb.material === material && (!pb.plantId || pb.plantId === '') && JSON.stringify((pb.components||[]).map(x=>({label:x.label,value:x.value}))) === compSig);
                  if (!exists) priceBreakdowns.push({ material, plantName: '', plantId: '', totalCost, components: sanitizedComponents, timestamp: Date.now() });
              }
            }

            // final cleanup: dedupe by material+plantId+total+components signature
            const cleaned = [];
            const seenSigs = new Set();
            priceBreakdowns.forEach(pb => {
              const sig = JSON.stringify({ material: pb.material, plantId: pb.plantId || '', total: Number(pb.totalCost || 0), comps: (pb.components||[]).map(c=>({label:c.label,value:c.value})) });
              if (!seenSigs.has(sig)) {
                seenSigs.add(sig);
                cleaned.push(pb);
              }
            });
            // remove empty-component entries if a total exists for same material+plantId (prefer entries with components)
            const finalList = [];
            const totalsIndex = {};
            cleaned.forEach(pb => {
              const key = `${pb.material}::${pb.plantId || ''}::${Number(pb.totalCost || 0)}`;
              if ((pb.components||[]).length) {
                totalsIndex[key] = true;
                finalList.push(pb);
              } else {
                // keep only if no component-bearing entry exists for same key
                if (!totalsIndex[key]) finalList.push(pb);
              }
            });
            localStorage.setItem('priceBreakdowns', JSON.stringify(finalList));
            try {
              const dashboardFrame = window.parent.document.querySelector('iframe[src="dashboard.html"]');
              if (dashboardFrame) dashboardFrame.contentWindow.postMessage({ type: 'priceBreakdowns', data: JSON.parse(localStorage.getItem('priceBreakdowns') || '[]') }, '*');
            } catch (e) { /* silent */ }
          } catch (e) {
            console.error('Price breakdown parse error', e);
          }

          // ----- New pass: explicit label($value) pairs -----
          // If the assistant wrote labels in the form "Transport Cost ($0.70)", use
          // those labels to tag matching components in priceBreakdowns and annotate
          // finalIRRs entries so the dashboard can show the correct label and unit.
          try {
            const labelValRegex = /([A-Za-z0-9 \-\/]{2,80}?)\s*\(\$?([0-9]+(?:\.[0-9]+)?)\)/g;
            const pb = JSON.parse(localStorage.getItem('priceBreakdowns') || '[]');
            const pairs = [];
            let m;
            while ((m = labelValRegex.exec(answerText)) !== null) {
              const rawLabel = (m[1] || '').trim();
              const num = Number(m[2]);
              if (!rawLabel || isNaN(num)) continue;
              const normLabel = capitalizeLabel(rawLabel.replace(/[\(\),:\.]+$/g,'').trim());
              pairs.push({ label: normLabel, value: num });
              // tag matching components in pb
              (pb || []).forEach(entry => {
                (entry.components || []).forEach(c => {
                  try {
                    if (c && c.value !== null && c.value !== undefined && Math.abs(Number(c.value) - num) < 1e-6) {
                      c.label = normLabel; // prefer assistant label
                      c.source = c.source || 'paired';
                    }
                  } catch (e) { /* per-component ignore */ }
                });
                // if a plant total matches this numeric, we don't override total label but keep association
              });
            }
            // Additional pass: label on one line and numeric on following line(s).
            // Handles assistant outputs like:
            // Production Cost\n5.00\nVendor Price\n1.00
            try {
              const lines = String(answerText || '').split(/\r?\n/);
              for (let i = 0; i < lines.length; i++) {
                const a = (lines[i] || '').trim();
                if (!a || !/[A-Za-z]/.test(a)) continue;
                // look ahead up to 2 lines for a numeric value
                let foundNum = null;
                for (let j = 1; j <= 2 && i + j < lines.length; j++) {
                  const cand = (lines[i + j] || '').trim();
                  if (!cand) continue;
                  const nm = cand.match(/^\$?([0-9]+(?:\.[0-9]+)?)/);
                  if (nm) { foundNum = Number(nm[1]); break; }
                }
                if (foundNum === null) continue;
                const normLabel = capitalizeLabel(a.replace(/[\(\),:\.]+$/g,'').trim());
                // avoid duplicates: only push if not already present
                if (!pairs.some(p => p.label === normLabel && Math.abs(p.value - foundNum) < 1e-6)) {
                  pairs.push({ label: normLabel, value: foundNum });
                  (pb || []).forEach(entry => {
                    (entry.components || []).forEach(c => {
                      try {
                        if (c && c.value !== null && c.value !== undefined && Math.abs(Number(c.value) - foundNum) < 1e-6) {
                          c.label = normLabel;
                          c.source = c.source || 'paired';
                        }
                      } catch (e) { /* per-component ignore */ }
                    });
                  });
                }
              }
            } catch (e) { /* ignore extra-pass errors */ }
            if (pairs.length) localStorage.setItem('priceBreakdowns', JSON.stringify(pb));
            // If we have a nearby material list like 'For material 100001, 100002, 100003'
            // followed by a sequence of label/value pairs, try to assign the pairs
            // to materials in order (chunked) so the dashboard can map Value N -> correct material.
            try {
              const materialListMatch = /For\s+material[s]?\s+((?:\d+\s*(?:,|and)?\s*)+)/i.exec(answerText);
              if (materialListMatch) {
                const matsRaw = materialListMatch[1];
                const materials = matsRaw.split(/(?:,|\band\b)/i).map(s => s.trim()).filter(Boolean);
                if (materials.length) {
                  // find label/value pairs that occur after the material list (within next 1000 chars)
                  const startIdx = materialListMatch.index + materialListMatch[0].length;
                  const tail = answerText.slice(startIdx, startIdx + 1000);
                  const pairRegex = /([A-Za-z0-9 \-\/]{2,80}?)\s*\(?\$?([0-9]+(?:\.[0-9]+)?)\)?/g;
                  const tailPairs = [];
                  let pm;
                  while ((pm = pairRegex.exec(tail)) !== null) {
                    const rl = (pm[1] || '').trim();
                    const nv = Number(pm[2]);
                    if (!rl || isNaN(nv)) continue;
                    // skip if rl looks like a sentence connector (short words)
                    if (/^(for|and|the|is|of|offers)$/i.test(rl)) continue;
                    tailPairs.push({ label: capitalizeLabel(rl.replace(/[\(\),:\.]+$/g,'').trim()), value: nv });
                  }
                  // If we discovered pairs and they evenly map to materials, chunk them
                  if (tailPairs.length && tailPairs.length % materials.length === 0) {
                    const chunkSize = tailPairs.length / materials.length;
                    const storedPB = JSON.parse(localStorage.getItem('priceBreakdowns') || '[]');
                    for (let mi = 0; mi < materials.length; mi++) {
                      const mat = materials[mi];
                      const comps = tailPairs.slice(mi * chunkSize, (mi + 1) * chunkSize).map(p => ({ label: p.label, value: p.value, unit: 'usd', source: 'paired' }));
                      // compute total as sum
                      const total = comps.reduce((s, c) => s + (c.value || 0), 0) || null;
                      // avoid duplicates: match by signature
                      const sig = JSON.stringify(comps.map(c => ({label: c.label, value: c.value})));
                      const exists = storedPB.find(pb => pb.material === mat && JSON.stringify((pb.components||[]).map(x=>({label:x.label,value:x.value}))) === sig);
                      if (!exists) storedPB.push({ material: mat, plantName: '', plantId: '', totalCost: total, components: comps, timestamp: Date.now() });
                    }
                    localStorage.setItem('priceBreakdowns', JSON.stringify(storedPB));
                  }
                }
              }
            } catch (e) { /* ignore grouping errors */ }
            // annotate finalIRRs (if present) with matching labels/units
            if (typeof finalIRRs !== 'undefined' && Array.isArray(finalIRRs) && pairs.length) {
              finalIRRs.forEach(fr => {
                try {
                  const raw = String(fr && (fr.raw || fr.irr || '') || '');
                  const m2 = raw.match(/([0-9]+(?:\.[0-9]+)?)/);
                  const val = m2 ? Number(m2[1]) : NaN;
                  if (isNaN(val)) return;
                  pairs.forEach(p => {
                    if (Math.abs(p.value - val) < 1e-6) {
                      fr.unit = 'usd';
                      fr.label = fr.label || p.label;
                      fr.source = fr.source || 'paired';
                      fr.raw = String(Number(p.value).toFixed(2));
                      fr.irr = fr.raw;
                    }
                  });
                } catch (e) { /* ignore per-entry */ }
              });
            }
          } catch (e) { /* non-fatal */ }

          // Persist all parsed IRR values (do not filter numeric-only entries here)
          try {
            // Attach 'unit' metadata: percent if token contains '%', or context implies IRR, else 'number'
            const annotated = finalIRRs.map(v => {
              try {
                const raw = (typeof v === 'object' && v !== null) ? (v.raw || v.irr || '') : String(v);
                // Check context: prefer percent if answer mentions IRR/percent or label suggests a rate
                const lowercaseAnswer = String(answerText || '').toLowerCase();
                const contextIndicatesIRR = /\birr\b/i.test(answerText) || /internal rate of return/i.test(lowercaseAnswer) || /%/.test(lowercaseAnswer) || /rate\b/.test(lowercaseAnswer);
                let unit = 'number';
                const numericVal = parseFloat(String(raw));
                // Explicit percent token wins, but if priceBreakdowns contain the same numeric monetary value
                // treat it as 'usd' (assistant sometimes writes money with a trailing '%'). We'll consult stored priceBreakdowns.
                const rawIsPercent = /%/.test(String(raw));
                if (rawIsPercent) {
                  // check stored priceBreakdowns for numeric monetary match
                  try {
                    const pb = JSON.parse(localStorage.getItem('priceBreakdowns') || '[]');
                    const m = String(raw).match(/([0-9]+(?:\.[0-9]+)?)/);
                    if (m) {
                      const num = Number(m[1]);
                      const found = (pb || []).some(e => {
                        if (e && e.totalCost != null && Math.abs(Number(e.totalCost) - num) < 1e-6) return true;
                        return (e.components || []).some(c => c && c.value != null && Math.abs(Number(c.value) - num) < 1e-6);
                      });
                      if (found) {
                        unit = 'usd';
                      } else {
                        unit = 'percent';
                      }
                    } else {
                      unit = 'percent';
                    }
                  } catch (e) {
                    unit = 'percent';
                  }
                } else if (/irr/i.test(String(v.label || '')) || /rate/i.test(String(v.label || ''))) {
                  // labeled IRR/rate entries are percent-like. Accept larger-than-1 values too (e.g., '17%')
                  unit = 'percent';
                } else if (contextIndicatesIRR) {
                  // If answer context mentions IRR or percent, treat reasonable numeric tokens as percent.
                  // Heuristic: if numeric value is between 0 (exclusive) and 100 (exclusive), consider percent.
                  if (!isNaN(numericVal) && numericVal > 0 && numericVal < 100) {
                    // Prefer percent for small decimals (<5) or values that look like percentages (>1)
                    if (numericVal < 5 || numericVal > 1) unit = 'percent';
                  }
                } else if (!isNaN(numericVal) && Math.abs(numericVal) < 1) {
                  // fallback: small decimals are likely percent/ratio
                  unit = 'percent';
                }
                return Object.assign({}, v, { unit });
              } catch (e) { return v; }
            });
            // ROOT FIX: if any annotated IRR numeric token exactly matches a monetary value
            // from the parsed priceBreakdowns, convert it to 'usd', attach the matched label
            // and mark source:'paired'. This prevents money tokens accidentally labeled as percent
            // from being rendered incorrectly in the dashboard.
            try {
              const pb = JSON.parse(localStorage.getItem('priceBreakdowns') || '[]');
              const moneyIndex = [];
              (pb || []).forEach(entry => {
                if (entry && entry.totalCost != null) moneyIndex.push({ value: Number(entry.totalCost), label: `Total (${entry.plantName||entry.plantId||''})`, source: entry.source || null });
                (entry.components || []).forEach(c => { if (c && c.value != null) moneyIndex.push({ value: Number(c.value), label: c.label || String(c.value), source: c.source || null }); });
              });
              annotated.forEach(a => {
                try {
                  const raw = String(a && (a.raw || a.irr) || '');
                  const m = String(a && a.irr || raw).match(/([0-9]+(?:\.[0-9]+)?)/);
                  if (!m) return;
                  const num = Number(m[1]);
                  if (isNaN(num)) return;
                  const match = moneyIndex.find(mi => Math.abs(Number(mi.value) - num) < 1e-6);
                  if (match) {
                    a.unit = 'usd';
                    a.label = a.label || match.label;
                    a.source = a.source || 'paired';
                    a.raw = String(Number(num).toFixed(2));
                    a.irr = a.raw;
                  }
                } catch (e) { /* per-entry ignore */ }
              });
            } catch (e) { /* non-fatal */ }
            // Normalize IRR entries: detect whether numeric tokens are proportions (e.g. 0.1612 -> 16.12%)
            // Heuristic: if any token in the batch contains an explicit '%' then treat small decimals (<1)
            // without '%' as proportions. Otherwise, if the majority of numeric tokens are < 1, treat
            // those as proportions as well. Convert all entries to percent values (unit: 'percent')
            // and store the numeric percent in irr (as a string with 4 decimal places).
            try {
              function normalizeAnnotatedAsPercent(list) {
                if (!Array.isArray(list) || !list.length) return list;
                const parsed = list.map(a => {
                  const raw = String(a && (a.raw || a.irr || '') || '').trim();
                  const hasPct = /%/.test(raw);
                  const n = parseFloat(raw.replace('%',''));
                  return { raw, hasPct, n: isNaN(n) ? null : n };
                }).filter(x => x.n !== null);
                if (!parsed.length) return list;
                const hasAnyPercentToken = parsed.some(p => p.hasPct);
                const majorityLessThanOne = parsed.filter(p => Math.abs(p.n) < 1).length > parsed.length / 2;
                const treatAsProportion = hasAnyPercentToken ? true : majorityLessThanOne;

                list.forEach((a, idx) => {
                  try {
                    let raw = String(a && (a.raw || a.irr || '') || '').trim();
                    if (!raw) return;
                    const hadPct = /%/.test(raw);
                    let num = parseFloat(raw.replace('%',''));
                    if (isNaN(num)) return;
                    if (!hadPct && treatAsProportion && Math.abs(num) < 1) {
                      num = num * 100;
                    }
                    // store as percent string with 4 decimals (preserve trailing zeros)
                    a.unit = 'percent';
                    a.irr = num.toFixed(4);
                    a.raw = a.irr;
                  } catch (e) { /* ignore per-entry */ }
                });
                return list;
              }
              normalizeAnnotatedAsPercent(annotated);
            } catch (e) { /* non-fatal */ }
            // Remove assistant-listed tokens like "Value 1", "Value2", "Value-1", etc.
            // Use a robust regex to catch multiple variants and formats.
            const VALUE_TOKEN_RE = /\bvalue\s*[-:]?\s*\d+\b/i;
            const VALUE_NO_SPACE_RE = /^value\d+/i;
            const filteredAnnotated = (annotated || []).filter(v => {
              try {
                const lab = String(v.label || '').trim();
                const raw = String(v.raw || v.irr || '').trim();
                if (VALUE_TOKEN_RE.test(lab) || VALUE_TOKEN_RE.test(raw)) return false;
                if (VALUE_NO_SPACE_RE.test(lab) || VALUE_NO_SPACE_RE.test(raw)) return false;
                return true;
              } catch (e) { return true; }
            });
            localStorage.setItem('irrValues', JSON.stringify(filteredAnnotated));
            try {
              const dashboardFrame = window.parent.document.querySelector('iframe[src="dashboard.html"]');
              if (dashboardFrame) dashboardFrame.contentWindow.postMessage({ type: 'irrData', data: filteredAnnotated }, '*');
            } catch (e) { /* silent */ }
          } catch (e) {
            console.error('Failed to persist irrValues', e);
          }
          let citeHtml = '';
          if(answerText){
            // Remove any explicit 'Value N' lines that the assistant sometimes emits
            // Catch multiple formats: 'Value 1', 'Value1', 'Value-1', 'Value 1:' etc.
            const VALUE_LINE_RE = /\bvalue\s*[-:]?\s*\d+\b/i;
            const VALUE_LINE_NOSPACE_RE = /^\s*value\d+/i;
            // Remove duplicate lines from the assistant answer (preserve first occurrence)
            const cleanedAnswer = (function dedupeAnswer(txt){
              const lines = String(txt).split(/\r?\n/).map(l => l.trim()).filter(Boolean);
              const out = [];
              const seen = new Set();
              lines.forEach(l => {
                if (VALUE_LINE_RE.test(l) || VALUE_LINE_NOSPACE_RE.test(l)) return;
                if (seen.has(l)) return;
                seen.add(l);
                out.push(l);
              });
              return out.join('\n').trim();
            })(answerText);

            

            answerRegion.innerHTML = `
              <div class="answer-card">
                 <span class="badge">Answer</span>
                 <div class="answer-body">${escapeHtml(cleanedAnswer)}</div>
                 ${citeHtml}
              </div>`;
          } else {
            answerRegion.innerHTML = '<p class="error-text">No answer returned.</p>';
          }
          // citation UI and blocks removed per request
          // Related questions chips
          if(Array.isArray(data?.answer?.relatedQuestions)){
            relatedWrap.innerHTML = '';
            data.answer.relatedQuestions.forEach(q => {
              const chip = document.createElement('button');
              chip.className='chip';
              chip.textContent=q;
              chip.onclick=()=>{ input.value=q; callApi(q); };
              relatedWrap.appendChild(chip);
            });
          }
        } catch (err) {
          console.error('API error:', err);
          answerRegion.innerHTML = '<p class="error-text">Error fetching answer.</p>';
        } finally {
          setLoading(false);
        }
      }
      btn.addEventListener('click', () => callApi(input.value.trim()));
      input.addEventListener('keydown', (e) => { if(e.key === 'Enter') callApi(input.value.trim()); });

      // Expose a way to inject token dynamically from parent (index.html) via postMessage
      window.addEventListener('message', (evt) => {
        if(!evt.data) return;
        if(evt.data.type === 'googleAccessToken'){
          bearerToken = evt.data.token;
          localStorage.setItem('searchAuthToken', bearerToken);
          console.log('Access token updated for API calls');
          tokenStatus.textContent = 'Auth: token received';
          btn.disabled = false;
        } else if(evt.data.type === 'firebaseLogin') {
          // Firebase ID token received (not directly usable for Discovery Engine REST)
          tokenStatus.textContent = 'Auth: firebase session active (waiting access token)';
        }
      });

      // Safety: after 5s if no token, remind user
      setTimeout(() => {
        if(!tokenAvailable()){
          tokenStatus.textContent = 'Auth: still waiting for Google access token. Please login again.';
        }
      }, 5000);

      // Utility to escape HTML
      function escapeHtml(str){
        return str.replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;','\'':'&#39;'}[c]));
      }

      // Helper to normalize/capitalize component labels
      function capitalizeLabel(s){
        if(!s) return '';
        return String(s).trim().split(/\s+/).map(w => w.charAt(0).toUpperCase() + w.slice(1).toLowerCase()).join(' ');
      }

      // Cleanup stored IRR values on load: normalize to 4-decimal percent strings and dedupe
      function cleanupStoredIrrValues(){
        try {
          const raw = JSON.parse(localStorage.getItem('irrValues') || '[]');
          if (!Array.isArray(raw) || !raw.length) return;
          const seen = new Set();
          const out = [];
          raw.forEach(a => {
            try {
              if (a == null) return;
              let s = (typeof a === 'object') ? (String(a.irr || a.raw || '')).trim() : String(a).trim();
              if (!s) return;
              const hasPct = /%/.test(s);
              let n = parseFloat(s.replace('%',''));
              if (isNaN(n)) return;
              if (!hasPct && Math.abs(n) < 1) n = n * 100;
              const formatted = Number(n.toFixed(4));
              if (seen.has(formatted)) return;
              seen.add(formatted);
              out.push({ irr: formatted.toFixed(4), unit: 'percent', raw: formatted.toFixed(4) });
            } catch (e) { /* ignore per-entry */ }
          });
          if (out.length) {
            localStorage.setItem('irrValues', JSON.stringify(out));
            try { const dashboardFrame = window.parent.document.querySelector('iframe[src="dashboard.html"]'); if (dashboardFrame) dashboardFrame.contentWindow.postMessage({ type: 'irrData', data: out }, '*'); } catch(e){}
          }
        } catch (e) { /* non-fatal */ }
      }

      // Run cleanup once at load so legacy duplicates are removed automatically
      try { cleanupStoredIrrValues(); } catch(e){}
    })();
  </script>
 
</body>

</html>