<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Custom Search UI</title>
  <link rel="stylesheet" href="style.css">
  <link rel="stylesheet" href="background.css">

  <style>
    body {
      margin: 0;
      padding: 0;
      font-family: 'Segoe UI', sans-serif;
      height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      /* Center horizontally */
      background: linear-gradient(135deg, #6a11cb 0%, #2575fc 100%);
    }

    /* Top area */
    .top-bar {
      width:100%;
      padding:34px 20px 10px;
      display:flex;
      justify-content:center;
      box-sizing:border-box;
      position:sticky;
      top:0;
      z-index:50;
      background:linear-gradient(135deg,#6a11cb 0%,#2575fc 100%);
    }

    .search-shell {
      width:100%;
      max-width:800px;
      background:#fff;
      display:flex;
      align-items:center;
      gap:10px;
      padding:10px 16px;
      border-radius:999px;
      border:1px solid #e2e8f0;
      box-shadow:0 4px 16px rgba(0,0,0,.12);
      transition:box-shadow .25s,border-color .25s;
    }
    .search-shell:focus-within { box-shadow:0 6px 22px rgba(0,0,0,.18); border-color:#bfdbfe; }
    .search-shell input { flex:1; border:none; outline:none; font-size:16px; background:transparent; font-family:inherit; }
    .icon-btn { background:#2575fc; color:#fff; border:none; padding:10px 22px; border-radius:24px; font-size:15px; cursor:pointer; display:flex; align-items:center; gap:6px; box-shadow:0 2px 6px rgba(0,0,0,.25); transition:background .25s, transform .15s; }
    .icon-btn:disabled { background:#9ca3af; cursor:not-allowed; box-shadow:none; }
    .icon-btn:not(:disabled):hover { background:#1d60cc; }
    .icon-btn:not(:disabled):active { transform:translateY(1px); }

    .page-wrapper { width:100%; display:flex; flex-direction:column; align-items:center; }
    .answer-wrapper { width:100%; max-width:900px; padding:0 20px 80px; box-sizing:border-box; }
    .status-line { margin:10px 0 18px; font-size:12px; font-family:monospace; color:#ffe08a; }

    .answer-card { background:#ffffff; border-radius:18px; padding:22px 26px 28px; box-shadow:0 4px 22px -4px rgba(0,0,0,.25); line-height:1.55; font-size:15px; position:relative; overflow:hidden;  margin-top: 10rem;}
    .answer-card h3 { margin:0 0 14px; font-size:14px; text-transform:uppercase; letter-spacing:1px; color:#475569; font-weight:600; }
    .faded-label { font-size:11px; text-transform:uppercase; letter-spacing:1px; color:#64748b; font-weight:600; }
    .chips { margin-top:18px; display:flex; flex-wrap:wrap; gap:8px; }
    .chip { background:#2575fc; color:#fff; border:none; padding:6px 12px; border-radius:24px; font-size:12px; cursor:pointer; line-height:1; display:inline-flex; align-items:center; gap:4px; box-shadow:0 2px 6px rgba(0,0,0,.2); }
    .chip:hover { background:#1d60cc; }
    .cite-bar { margin-top:14px; display:flex; flex-wrap:wrap; gap:6px; }
    .cite { background:#f1f5f9; color:#475569; padding:4px 8px; border-radius:6px; font-size:11px; cursor:pointer; border:1px solid #e2e8f0; }
    .cite.active { background:#2575fc; color:#fff; border-color:#1d60cc; }
    .citation-detail { margin-top:10px; background:#f8fafc; border:1px solid #e2e8f0; padding:12px 14px; border-radius:10px; font-size:12px; max-height:220px; overflow:auto; }
    .skeleton { background:linear-gradient(90deg,#f1f5f9 25%,#e2e8f0 37%,#f1f5f9 63%); background-size:400% 100%; animation:shimmer 1.4s ease infinite; border-radius:6px; }
    .sk-line { height:14px; margin:6px 0; }
    @keyframes shimmer { 0% {background-position:100% 0;} 100% {background-position:0 0;} }
    .empty-hint { font-size:13px; color:#e2e8f0; margin-top:40px; text-align:center; }
    .error-text { color:#dc2626; font-weight:500; }
    .badge { position:absolute; top:10px; right:14px; background:#eef2ff; color:#3730a3; font-size:11px; padding:4px 8px; border-radius:14px; font-weight:600; letter-spacing:.5px; }
    .mini { font-size:11px; opacity:.85; }
    .ref-block { margin-bottom:14px; }
    .ref-block pre { white-space:pre-wrap; word-break:break-word; font-size:11px; background:#fff; margin:6px 0 0; padding:8px 10px; border:1px solid #e2e8f0; border-radius:6px; }
  </style>
</head>

<body>
  <div class="page-wrapper">
    <div class="top-bar">
      <div style="width:100%;display:flex;flex-direction:column;align-items:center;gap:10px;">
        <div style="width:100%;max-width:800px;display:flex;align-items:center;justify-content:flex-start;margin-bottom:10px;">
          <label for="engineIdInput" style="font-size:15px;color:#2575fc;font-weight:700;margin-right:10px;">App ID</label>
          <input id="engineIdInput" type="text" value="z-app_1753360472660" style="font-size:15px;padding:8px 16px;border-radius:14px;border:1px solid #e2e8f0;width:260px;background:#fff;color:#2575fc;font-weight:600;outline:none;transition:border-color .2s;box-shadow:0 2px 12px rgba(96,165,250,0.10);" />
        </div>
        <div class="search-shell" id="searchShell">
          <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="#64748b" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="margin-right:10px;"><circle cx="11" cy="11" r="8"/><line x1="21" y1="21" x2="16.65" y2="16.65"/></svg>
          <input id="searchInput" class="modern-search" placeholder="" autocomplete="off" />
          <button id="askBtn" class="icon-btn" disabled>
            <span>Ask</span>
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="22" y1="2" x2="11" y2="13"/><polygon points="22 2 15 22 11 13 2 9 22 2"/></svg>
          </button>
          <div id="tokenInfo" style="display:none;margin:8px 0 0 0;font-size:12px;color:#64748b;background:#f1f5f9;padding:4px 8px;border-radius:4px;max-width:80%;word-break:break-all;"></div>
        </div>
      </div>
    </div>
    <div class="answer-wrapper">
      <div id="tokenStatus" class="status-line">Auth: waiting for login...</div>
      <div id="answerRegion">
        <p class="empty-hint">Start typing a question and press Enter or click Ask.</p>
      </div>
      <div id="relatedQuestions" class="chips"></div>
      <div id="citationsPanel"></div>
    </div>
  </div>

  <script>
    (function(){
      let defaultEngineId = "z-app_1753360472660";
      let engineId = localStorage.getItem('engineId') || defaultEngineId;
      const engineInput = document.getElementById('engineIdInput');
      function getApiUrl() {
        return `https://us-discoveryengine.googleapis.com/v1alpha/projects/19437895168/locations/us/collections/default_collection/engines/${engineId}/servingConfigs/default_search:answer`;
      }
      if(engineInput){
        engineInput.value = engineId;
        engineInput.addEventListener('input', function(){
          engineId = engineInput.value.trim() || defaultEngineId;
          localStorage.setItem('engineId', engineId);
        });
      }
      // NOTE: Do NOT hardcode a bearer token in production. This is only for quick testing.
      let bearerToken = "REPLACE_WITH_RUNTIME_TOKEN"; // placeholder
      // Restore token from localStorage if present
      const storedToken = localStorage.getItem('searchAuthToken');
      if(storedToken && storedToken.length > 20){
        bearerToken = storedToken;
      }
    const tokenInfo = document.getElementById('tokenInfo');
    tokenInfo.textContent = bearerToken && bearerToken !== 'REPLACE_WITH_RUNTIME_TOKEN' ? `Access Token: ${bearerToken}` : 'No access token set.';
      const input = document.getElementById('searchInput');
      const btn = document.getElementById('askBtn');
      const relatedWrap = document.getElementById('relatedQuestions');
      const tokenStatus = document.getElementById('tokenStatus');
      const answerRegion = document.getElementById('answerRegion');
      const citationsPanel = document.getElementById('citationsPanel');

      function setLoading(isLoading){
        if(isLoading){
          btn.disabled = true; btn.classList.add('loading');
          btn.innerHTML = '<span>Loading</span>';
          answerRegion.innerHTML = `
                <div class="answer-card">
                  <span class="badge">Generating</span>
                  <div class="sk-line skeleton" style="width:60%"></div>
                  <div class="sk-line skeleton" style="width:85%"></div>
                  <div class="sk-line skeleton" style="width:78%"></div>
                  <div class="sk-line skeleton" style="width:66%"></div>
                  <div class="sk-line skeleton" style="width:40%"></div>
                </div>`;
        } else {
          btn.disabled = false; btn.classList.remove('loading');
          btn.innerHTML = '<span>Ask</span> <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="22" y1="2" x2="11" y2="13"/><polygon points="22 2 15 22 11 13 2 9 22 2"/></svg>';
        }
      }

      function tokenAvailable(){
        return bearerToken && bearerToken !== 'REPLACE_WITH_RUNTIME_TOKEN' && bearerToken.length > 20;
      }

      function ensureTokenOrWarn(){
        if(!tokenAvailable()){
          answerRegion.innerHTML = '<p class="error-text">You must login first. Token not received.</p>';
          return false;
        }
        return true;
      }

      async function callApi(queryText){
        if(!ensureTokenOrWarn()) return;
        if(!queryText){
          answerRegion.innerHTML = '<p class="error-text">Enter a question.</p>';
          return;
        }
        tokenInfo.textContent = bearerToken && bearerToken !== 'REPLACE_WITH_RUNTIME_TOKEN' ? `Access Token: ${bearerToken}` : 'No access token set.';
        setLoading(true);
        relatedWrap.innerHTML = '';
        citationsPanel.innerHTML = '';
        try {
          const payload = {
            query: { text: queryText, queryId: "" },
            session: "",
            relatedQuestionsSpec: { enable: true },
            answerGenerationSpec: {
              ignoreAdversarialQuery: true,
              ignoreNonAnswerSeekingQuery: false,
              ignoreLowRelevantContent: true,
              multimodalSpec: {},
              includeCitations: true,
              promptSpec: { preamble: "Given the conversation between a user and a helpful assistant and some search results, create a final answer for the assistant. The answer should use all relevant information from the search results, not introduce any additional information, and use exactly the same words as the search results when possible. The assistant's answer should be no more than 50 words. The user is an expert who has an in-depth understanding of the subject matter. The assistant should answer in a technical manner that uses specialized knowledge and terminology when it helps answer the query." },
              modelSpec: { modelVersion: "stable" }
            }
          };

          const res = await fetch(getApiUrl(), {
            method: 'POST',
            headers: {
              'Authorization': 'Bearer ' + bearerToken,
              'Content-Type': 'application/json'
            },
            body: JSON.stringify(payload)
          });
          const data = await res.json();
          console.log('Raw API response:', data);
          const answerText = data?.answer?.answerText || '';
          const refs = data?.answer?.references || [];
          // IRR extraction: support comma-separated lists, plain percent values, year-based, labeled IRRs, no duplicates 
          let irrValues = [];
          const seenIRR = new Set();
          // 1. Year-based IRRs: '0.1514 for 2 years', '0.1514% (2 years)', etc.
          const irrForYearRegex = /([0-9]+\.[0-9]+%?)\s*for\s*(\d+) years?/gi;
          let forYearMatch;
          while ((forYearMatch = irrForYearRegex.exec(answerText)) !== null) {
            const key = forYearMatch[1] + '_year_' + forYearMatch[2];
            if (!seenIRR.has(key)) {
              irrValues.push({ irr: forYearMatch[1], year: forYearMatch[2], label: `Year ${forYearMatch[2]}`, raw: forYearMatch[0] });
              seenIRR.add(key);
            }
          }
          const irrYearRegex = /([0-9]+\.[0-9]+%?)\s*\((\d+) years?\)/gi;
          let yearMatch;
          while ((yearMatch = irrYearRegex.exec(answerText)) !== null) {
            const key = yearMatch[1];
            if (!seenIRR.has(key)) {
              irrValues.push({ irr: yearMatch[1], year: yearMatch[2], raw: yearMatch[0] });
              seenIRR.add(key);
            }
          }
          // 2. IRR with labels: '0.1160% (Base IRR)', '0.1417 (Project IRR)', etc.
          const irrLabelRegex = /([0-9]+\.[0-9]+%?)\s*\(([^)]+IRR)\)/gi;
          let labelMatch;
          while ((labelMatch = irrLabelRegex.exec(answerText)) !== null) {
            const key = labelMatch[1];
            if (!seenIRR.has(key)) {
              irrValues.push({ irr: labelMatch[1], label: labelMatch[2].trim(), raw: labelMatch[0] });
              seenIRR.add(key);
            }
          }
          // 3. Comma-separated IRR lists: 'It is 0.732..., 0.623..., ...'
          const irrCommaListRegex = /(?:is|are|include|varies\.|values?\s*[:=])\s*([0-9.,\sand%]+)/gi;
          let commaListMatch;
          while ((commaListMatch = irrCommaListRegex.exec(answerText)) !== null) {
            // Replace 'and' with comma, then split
            const cleaned = commaListMatch[1].replace(/\band\b/gi, ',');
            const numbers = cleaned.match(/([0-9]+\.[0-9]+%?|[0-9]+%?)/g);
            if (numbers) {
              numbers.forEach(n => {
                if (!seenIRR.has(n)) {
                  irrValues.push({ irr: n, raw: n });
                  seenIRR.add(n);
                }
              });
            }
          }
          // 4. IRR percent values: '0.1741%', etc. (not associated with years/labels)
          const irrPercentRegex = /([0-9]+\.[0-9]+)\s*%/g;
          let percentMatch;
          while ((percentMatch = irrPercentRegex.exec(answerText)) !== null) {
            const key = percentMatch[0];
            if (!seenIRR.has(key)) {
              irrValues.push({ irr: percentMatch[0], raw: percentMatch[0] });
              seenIRR.add(key);
            }
          }
          // 5. Standalone decimal IRR values (not percent, not year, not label)
          // 6. IRR percent values with year context: '0.1741% over 10 years'
          // 7. Handle IRR values for years 2-10 and prevent duplicate plain values
          const yearIrrs = [];
          const yearIrrRegex = /([0-9]+\.[0-9]+%?)\s*(?:over|for)\s*(\d+) years?/gi;
          let yearIrrMatch;
          while ((yearIrrMatch = yearIrrRegex.exec(answerText)) !== null) {
            const key = yearIrrMatch[1] + '_year_' + yearIrrMatch[2];
            if (!irrValues.some(v => v.irr === yearIrrMatch[1] && v.year == yearIrrMatch[2])) {
              irrValues.push({ irr: yearIrrMatch[1], year: yearIrrMatch[2], label: `Year ${yearIrrMatch[2]}`, raw: yearIrrMatch[0] });
              yearIrrs.push(yearIrrMatch[1]);
            }
          }
          // Remove plain values that match a year IRR
          // Remove plain values that match a year IRR, and prevent duplicate year entries
          irrValues = irrValues.filter((v, i, arr) => {
            // Remove plain value if a year IRR exists for this value
            if (!v.year && yearIrrs.includes(v.irr)) {
              return false;
            }
            // Remove duplicate year entries (same year and value)
            if (v.year) {
              // Only keep the first occurrence of this year/value
              return arr.findIndex(x => x.year === v.year && x.irr === v.irr) === i;
            }
            // Remove duplicate plain values (same value, no year)
            if (!v.year) {
              return arr.findIndex(x => !x.year && x.irr === v.irr) === i;
            }
            return true;
          });
          const irrPercentYearRegex = /([0-9]+\.[0-9]+%)\s*(?:over|for)\s*(\d+) years?/gi;
          let percentYearMatch;
          while ((percentYearMatch = irrPercentYearRegex.exec(answerText)) !== null) {
            const key = percentYearMatch[1] + '_year_' + percentYearMatch[2];
            if (!seenIRR.has(key)) {
              irrValues.push({ irr: percentYearMatch[1], year: percentYearMatch[2], label: `Year ${percentYearMatch[2]}`, raw: percentYearMatch[0] });
              seenIRR.add(key);
            }
          }
          const irrDecimalRegex = /(?<![\d%])([0-9]+\.[0-9]+)(?![\d%])/g;
          let decimalMatch;
          while ((decimalMatch = irrDecimalRegex.exec(answerText)) !== null) {
            const key = decimalMatch[1];
            // Only add if not already captured with year or label
            if (!irrValues.some(v => v.irr === key && (v.year || v.label))) {
              if (!seenIRR.has(key)) {
                irrValues.push({ irr: key, raw: key });
                seenIRR.add(key);
              }
            }
          }
          // Overwrite localStorage with IRR values in answer order, no duplicates
          // Final deduplication: keep only the most specific entry for each IRR value
          const uniqueIRRs = {};
          irrValues.forEach(v => {
            const key = v.irr;
            // Prefer year/label over plain value
            if (!uniqueIRRs[key]) {
              uniqueIRRs[key] = v;
            } else {
              if ((v.year || v.label) && !uniqueIRRs[key].year && !uniqueIRRs[key].label) {
                uniqueIRRs[key] = v;
              }
            }
          });
          // Remove duplicate year entries
          const finalIRRs = Object.values(uniqueIRRs).filter((v, i, arr) => {
            if (v.year) {
              return arr.findIndex(x => x.year === v.year && x.irr === v.irr) === i;
            }
            return true;
          });
          localStorage.setItem('irrValues', JSON.stringify(finalIRRs));
          try {
            const dashboardFrame = window.parent.document.querySelector('iframe[src="dashboard.html"]');
            if(dashboardFrame) dashboardFrame.contentWindow.postMessage({ type: 'irrData', data: irrValues }, '*');
          } catch(e) { /* silent fail */ }
          let citeHtml = '';
          if(refs.length){
            citeHtml = '<div class="cite-bar">' + refs.map((r,i)=>`<span class="cite" data-cite-index="${i}">Ref ${i+1}</span>`).join('') + '</div>';
          }
          if(answerText){
            answerRegion.innerHTML = `
              <div class="answer-card">
                 <span class="badge">Answer</span>
                 <div class="answer-body">${escapeHtml(answerText)}</div>
                 ${citeHtml}
              </div>`;
          } else {
            answerRegion.innerHTML = '<p class="error-text">No answer returned.</p>';
          }
          // Build citation reference blocks (hidden until clicked)
          if(refs.length){
            citationsPanel.innerHTML = '<div id="refBlocks" style="margin-top:18px;"></div>';
            const refContainer = document.getElementById('refBlocks');
            refs.forEach((r,i)=>{
              const content = r?.chunkInfo?.content || '(no excerpt)';
              const uri = r?.chunkInfo?.documentMetadata?.uri || '';
              const title = r?.chunkInfo?.documentMetadata?.title || 'Source';
              const block = document.createElement('div');
              block.className = 'ref-block';
              block.style.display = 'none';
              block.id = 'ref-'+i;
              block.innerHTML = `<div class="faded-label">REF ${i+1}: ${escapeHtml(title)}</div><pre>${escapeHtml(content.substring(0,1600))}${content.length>1600?'...':''}</pre>${uri?`<div class="mini">URI: ${escapeHtml(uri)}</div>`:''}`;
              refContainer.appendChild(block);
            });
            // Citation click handler
            answerRegion.querySelectorAll('.cite').forEach(el => {
              el.addEventListener('click', ()=>{
                const idx = el.getAttribute('data-cite-index');
                const target = document.getElementById('ref-'+idx);
                const active = el.classList.contains('active');
                // toggle
                answerRegion.querySelectorAll('.cite').forEach(c=>c.classList.remove('active'));
                document.querySelectorAll('.ref-block').forEach(b=> b.style.display='none');
                if(!active){
                  el.classList.add('active');
                  target.style.display='block';
                }
              });
            });
          }
          // Related questions chips
          if(Array.isArray(data?.answer?.relatedQuestions)){
            relatedWrap.innerHTML = '';
            data.answer.relatedQuestions.forEach(q => {
              const chip = document.createElement('button');
              chip.className='chip';
              chip.textContent=q;
              chip.onclick=()=>{ input.value=q; callApi(q); };
              relatedWrap.appendChild(chip);
            });
          }
        } catch (err) {
          console.error('API error:', err);
          answerRegion.innerHTML = '<p class="error-text">Error fetching answer.</p>';
        } finally {
          setLoading(false);
        }
      }
      btn.addEventListener('click', () => callApi(input.value.trim()));
      input.addEventListener('keydown', (e) => { if(e.key === 'Enter') callApi(input.value.trim()); });

      // Expose a way to inject token dynamically from parent (index.html) via postMessage
      window.addEventListener('message', (evt) => {
        if(!evt.data) return;
        if(evt.data.type === 'googleAccessToken'){
          bearerToken = evt.data.token;
          localStorage.setItem('searchAuthToken', bearerToken);
          console.log('Access token updated for API calls');
          tokenStatus.textContent = 'Auth: token received';
          btn.disabled = false;
        } else if(evt.data.type === 'firebaseLogin') {
          // Firebase ID token received (not directly usable for Discovery Engine REST)
          tokenStatus.textContent = 'Auth: firebase session active (waiting access token)';
        }
      });

      // Safety: after 5s if no token, remind user
      setTimeout(() => {
        if(!tokenAvailable()){
          tokenStatus.textContent = 'Auth: still waiting for Google access token. Please login again.';
        }
      }, 5000);

      // Utility to escape HTML
      function escapeHtml(str){
        return str.replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;','\'':'&#39;'}[c]));
      }
    })();
  </script>
 
</body>

</html>