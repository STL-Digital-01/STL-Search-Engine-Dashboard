<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Custom Search UI</title>
  <link rel="stylesheet" href="style.css">
  <link rel="stylesheet" href="background.css">

  <style>
    body {
      margin: 0;
      padding: 0;
      font-family: 'Segoe UI', sans-serif;
      height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      /* Center horizontally */
      background: linear-gradient(135deg, #6a11cb 0%, #2575fc 100%);
    }

    /* Top area */
    .top-bar {
      width:100%;
      padding:34px 20px 10px;
      display:flex;
      justify-content:center;
      box-sizing:border-box;
      position:sticky;
      top:0;
      z-index:50;
      background:linear-gradient(135deg,#6a11cb 0%,#2575fc 100%);
    }

    .search-shell {
      width:100%;
      max-width:800px;
      background:#fff;
      display:flex;
      align-items:center;
      gap:10px;
      padding:10px 16px;
      border-radius:999px;
      border:1px solid #e2e8f0;
      box-shadow:0 4px 16px rgba(0,0,0,.12);
      transition:box-shadow .25s,border-color .25s;
    }
    .search-shell:focus-within { box-shadow:0 6px 22px rgba(0,0,0,.18); border-color:#bfdbfe; }
    .search-shell input { flex:1; border:none; outline:none; font-size:16px; background:transparent; font-family:inherit; }
    .icon-btn { background:#2575fc; color:#fff; border:none; padding:10px 22px; border-radius:24px; font-size:15px; cursor:pointer; display:flex; align-items:center; gap:6px; box-shadow:0 2px 6px rgba(0,0,0,.25); transition:background .25s, transform .15s; }
    .icon-btn:disabled { background:#9ca3af; cursor:not-allowed; box-shadow:none; }
    .icon-btn:not(:disabled):hover { background:#1d60cc; }
    .icon-btn:not(:disabled):active { transform:translateY(1px); }

    .page-wrapper { width:100%; display:flex; flex-direction:column; align-items:center; }
    .answer-wrapper { width:100%; max-width:900px; padding:0 20px 80px; box-sizing:border-box; }
    .status-line { margin:10px 0 18px; font-size:12px; font-family:monospace; color:#ffe08a; }

    .answer-card { background:#ffffff; border-radius:18px; padding:22px 26px 28px; box-shadow:0 4px 22px -4px rgba(0,0,0,.25); line-height:1.55; font-size:15px; position:relative; overflow:hidden;  margin-top: 10rem;}
    .answer-card h3 { margin:0 0 14px; font-size:14px; text-transform:uppercase; letter-spacing:1px; color:#475569; font-weight:600; }
    .faded-label { font-size:11px; text-transform:uppercase; letter-spacing:1px; color:#64748b; font-weight:600; }
    .chips { margin-top:18px; display:flex; flex-wrap:wrap; gap:8px; }
    .chip { background:#2575fc; color:#fff; border:none; padding:6px 12px; border-radius:24px; font-size:12px; cursor:pointer; line-height:1; display:inline-flex; align-items:center; gap:4px; box-shadow:0 2px 6px rgba(0,0,0,.2); }
    .chip:hover { background:#1d60cc; }
  /* citation UI removed */
    .citation-detail { margin-top:10px; background:#f8fafc; border:1px solid #e2e8f0; padding:12px 14px; border-radius:10px; font-size:12px; max-height:220px; overflow:auto; }
    .skeleton { background:linear-gradient(90deg,#f1f5f9 25%,#e2e8f0 37%,#f1f5f9 63%); background-size:400% 100%; animation:shimmer 1.4s ease infinite; border-radius:6px; }
    .sk-line { height:14px; margin:6px 0; }
    @keyframes shimmer { 0% {background-position:100% 0;} 100% {background-position:0 0;} }
    .empty-hint { font-size:13px; color:#e2e8f0; margin-top:40px; text-align:center; }
    .error-text { color:#dc2626; font-weight:500; }
    .badge { position:absolute; top:10px; right:14px; background:#eef2ff; color:#3730a3; font-size:11px; padding:4px 8px; border-radius:14px; font-weight:600; letter-spacing:.5px; }
    .mini { font-size:11px; opacity:.85; }
    .ref-block { margin-bottom:14px; }
    .ref-block pre { white-space:pre-wrap; word-break:break-word; font-size:11px; background:#fff; margin:6px 0 0; padding:8px 10px; border:1px solid #e2e8f0; border-radius:6px; }
  </style>
</head>

<body>
  <div class="page-wrapper">
    <div class="top-bar">
      <div style="width:100%;display:flex;flex-direction:column;align-items:center;gap:10px;">
        <div style="width:100%;max-width:800px;display:flex;align-items:center;justify-content:flex-start;margin-bottom:10px;">
          <label for="engineIdInput" style="font-size:15px;color:#2575fc;font-weight:700;margin-right:10px;">App ID</label>
          <input id="engineIdInput" type="text" value="z-app_1753360472660" style="font-size:15px;padding:8px 16px;border-radius:14px;border:1px solid #e2e8f0;width:260px;background:#fff;color:#2575fc;font-weight:600;outline:none;transition:border-color .2s;box-shadow:0 2px 12px rgba(96,165,250,0.10);" />
        </div>
        <div class="search-shell" id="searchShell">
          <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="#64748b" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="margin-right:10px;"><circle cx="11" cy="11" r="8"/><line x1="21" y1="21" x2="16.65" y2="16.65"/></svg>
          <input id="searchInput" class="modern-search" placeholder="" autocomplete="off" />
          <button id="askBtn" class="icon-btn" disabled>
            <span>Ask</span>
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="22" y1="2" x2="11" y2="13"/><polygon points="22 2 15 22 11 13 2 9 22 2"/></svg>
          </button>
          <div id="tokenInfo" style="display:none;margin:8px 0 0 0;font-size:12px;color:#64748b;background:#f1f5f9;padding:4px 8px;border-radius:4px;max-width:80%;word-break:break-all;"></div>
        </div>
      </div>
    </div>
    <div class="answer-wrapper">
      <div id="tokenStatus" class="status-line">Auth: waiting for login...</div>
      <div id="answerRegion">
        <p class="empty-hint">Start typing a question and press Enter or click Ask.</p>
      </div>
      <div id="relatedQuestions" class="chips"></div>
      <div id="citationsPanel"></div>
    </div>
  </div>

  <script>
    (function(){
      let defaultEngineId = "z-app_1753360472660";
      let engineId = localStorage.getItem('engineId') || defaultEngineId;
      const engineInput = document.getElementById('engineIdInput');
      function getApiUrl() {
        return `https://us-discoveryengine.googleapis.com/v1alpha/projects/19437895168/locations/us/collections/default_collection/engines/${engineId}/servingConfigs/default_search:answer`;
      }
      if(engineInput){
        engineInput.value = engineId;
        engineInput.addEventListener('input', function(){
          engineId = engineInput.value.trim() || defaultEngineId;
          localStorage.setItem('engineId', engineId);
        });
      }
      // NOTE: Do NOT hardcode a bearer token in production. This is only for quick testing.
      let bearerToken = "REPLACE_WITH_RUNTIME_TOKEN"; // placeholder
      // Restore token from localStorage if present
      const storedToken = localStorage.getItem('searchAuthToken');
      if(storedToken && storedToken.length > 20){
        bearerToken = storedToken;
      }
    const tokenInfo = document.getElementById('tokenInfo');
    tokenInfo.textContent = bearerToken && bearerToken !== 'REPLACE_WITH_RUNTIME_TOKEN' ? `Access Token: ${bearerToken}` : 'No access token set.';
      const input = document.getElementById('searchInput');
      const btn = document.getElementById('askBtn');
      const relatedWrap = document.getElementById('relatedQuestions');
      const tokenStatus = document.getElementById('tokenStatus');
      const answerRegion = document.getElementById('answerRegion');
      const citationsPanel = document.getElementById('citationsPanel');

      function setLoading(isLoading){
        if(isLoading){
          btn.disabled = true; btn.classList.add('loading');
          btn.innerHTML = '<span>Loading</span>';
          answerRegion.innerHTML = `
                <div class="answer-card">
                  <span class="badge">Generating</span>
                  <div class="sk-line skeleton" style="width:60%"></div>
                  <div class="sk-line skeleton" style="width:85%"></div>
                  <div class="sk-line skeleton" style="width:78%"></div>
                  <div class="sk-line skeleton" style="width:66%"></div>
                  <div class="sk-line skeleton" style="width:40%"></div>
                </div>`;
        } else {
          btn.disabled = false; btn.classList.remove('loading');
          btn.innerHTML = '<span>Ask</span> <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="22" y1="2" x2="11" y2="13"/><polygon points="22 2 15 22 11 13 2 9 22 2"/></svg>';
        }
      }

      function tokenAvailable(){
        return bearerToken && bearerToken !== 'REPLACE_WITH_RUNTIME_TOKEN' && bearerToken.length > 20;
      }

      function ensureTokenOrWarn(){
        if(!tokenAvailable()){
          answerRegion.innerHTML = '<p class="error-text">You must login first. Token not received.</p>';
          return false;
        }
        return true;
      }

      async function callApi(queryText){
        if(!ensureTokenOrWarn()) return;
        if(!queryText){
          answerRegion.innerHTML = '<p class="error-text">Enter a question.</p>';
          return;
        }
        tokenInfo.textContent = bearerToken && bearerToken !== 'REPLACE_WITH_RUNTIME_TOKEN' ? `Access Token: ${bearerToken}` : 'No access token set.';
        setLoading(true);
        relatedWrap.innerHTML = '';
        citationsPanel.innerHTML = '';
        try {
          const payload = {
            query: { text: queryText, queryId: "" },
            session: "",
            relatedQuestionsSpec: { enable: true },
              answerGenerationSpec: {
              ignoreAdversarialQuery: true,
              ignoreNonAnswerSeekingQuery: false,
              ignoreLowRelevantContent: true,
              multimodalSpec: {},
              // citations removed from payload
              promptSpec: { preamble: "Given the conversation between a user and a helpful assistant and some search results, create a final answer for the assistant. The answer should use all relevant information from the search results, not introduce any additional information, and use exactly the same words as the search results when possible. The assistant's answer should be no more than 50 words. The user is an expert who has an in-depth understanding of the subject matter. The assistant should answer in a technical manner that uses specialized knowledge and terminology when it helps answer the query." },
              modelSpec: { modelVersion: "stable" }
            }
          };

          const res = await fetch(getApiUrl(), {
            method: 'POST',
            headers: {
              'Authorization': 'Bearer ' + bearerToken,
              'Content-Type': 'application/json'
            },
            body: JSON.stringify(payload)
          });
          const data = await res.json();
          console.log('Raw API response:', data);
          const answerText = data?.answer?.answerText || '';
          // IRR extraction: support comma-separated lists, plain percent values, year-based, labeled IRRs, no duplicates 
          let irrValues = [];
          const seenIRR = new Set();
          // 1. Year-based IRRs: e.g. '0.1514 for 2 years' or '0.1514% (2 years)'
          const irrForYearRegex = /([0-9]+\.[0-9]+%?)\s*for\s*(\d+) years?/gi;
          let forYearMatch;
          while ((forYearMatch = irrForYearRegex.exec(answerText)) !== null) {
            const key = forYearMatch[1] + '_year_' + forYearMatch[2];
            if (!seenIRR.has(key)) {
              irrValues.push({ irr: forYearMatch[1], year: forYearMatch[2], label: `Year ${forYearMatch[2]}`, raw: forYearMatch[0] });
              seenIRR.add(key);
            }
          }
          const irrYearRegex = /([0-9]+\.[0-9]+%?)\s*\((\d+) years?\)/gi;
          let yearMatch;
          while ((yearMatch = irrYearRegex.exec(answerText)) !== null) {
            const key = yearMatch[1];
            if (!seenIRR.has(key)) {
              irrValues.push({ irr: yearMatch[1], year: yearMatch[2], raw: yearMatch[0] });
              seenIRR.add(key);
            }
          }
          // 2. IRR with labels: e.g. '0.1160% (Base IRR)' or '0.XXXX (Project IRR)'
          const irrLabelRegex = /([0-9]+\.[0-9]+%?)\s*\(([^)]+IRR)\)/gi;
          let labelMatch;
          while ((labelMatch = irrLabelRegex.exec(answerText)) !== null) {
            const key = labelMatch[1];
            if (!seenIRR.has(key)) {
              irrValues.push({ irr: labelMatch[1], label: labelMatch[2].trim(), raw: labelMatch[0] });
              seenIRR.add(key);
            }
          }
          // 3. Comma-separated IRR lists: 'It is 0.732..., 0.623..., ...'
          const irrCommaListRegex = /(?:is|are|include|varies\.|values?\s*[:=])\s*([0-9.,\sand%]+)/gi;
          let commaListMatch;
          while ((commaListMatch = irrCommaListRegex.exec(answerText)) !== null) {
            // Replace 'and' with comma, then split
            const cleaned = commaListMatch[1].replace(/\band\b/gi, ',');
            const numbers = cleaned.match(/([0-9]+\.[0-9]+%?|[0-9]+%?)/g);
            if (numbers) {
              numbers.forEach(n => {
                if (!seenIRR.has(n)) {
                  irrValues.push({ irr: n, raw: n });
                  seenIRR.add(n);
                }
              });
            }
          }
          // 4. IRR percent values: '0.1741%', etc. (not associated with years/labels)
          const irrPercentRegex = /([0-9]+\.[0-9]+)\s*%/g;
          let percentMatch;
          while ((percentMatch = irrPercentRegex.exec(answerText)) !== null) {
            const key = percentMatch[0];
            if (!seenIRR.has(key)) {
              irrValues.push({ irr: percentMatch[0], raw: percentMatch[0] });
              seenIRR.add(key);
            }
          }
          // 5. Standalone decimal IRR values (not percent, not year, not label)
          // 6. IRR percent values with year context: '0.1741% over 10 years'
          // 7. Handle IRR values for years 2-10 and prevent duplicate plain values
          const yearIrrs = [];
          const yearIrrRegex = /([0-9]+\.[0-9]+%?)\s*(?:over|for)\s*(\d+) years?/gi;
          let yearIrrMatch;
          while ((yearIrrMatch = yearIrrRegex.exec(answerText)) !== null) {
            const key = yearIrrMatch[1] + '_year_' + yearIrrMatch[2];
            if (!irrValues.some(v => v.irr === yearIrrMatch[1] && v.year == yearIrrMatch[2])) {
              irrValues.push({ irr: yearIrrMatch[1], year: yearIrrMatch[2], label: `Year ${yearIrrMatch[2]}`, raw: yearIrrMatch[0] });
              yearIrrs.push(yearIrrMatch[1]);
            }
          }
          // Remove plain values that match a year IRR
          // Remove plain values that match a year IRR, and prevent duplicate year entries
          irrValues = irrValues.filter((v, i, arr) => {
            // Remove plain value if a year IRR exists for this value
            if (!v.year && yearIrrs.includes(v.irr)) {
              return false;
            }
            // Remove duplicate year entries (same year and value)
            if (v.year) {
              // Only keep the first occurrence of this year/value
              return arr.findIndex(x => x.year === v.year && x.irr === v.irr) === i;
            }
            // Remove duplicate plain values (same value, no year)
            if (!v.year) {
              return arr.findIndex(x => !x.year && x.irr === v.irr) === i;
            }
            return true;
          });
          const irrPercentYearRegex = /([0-9]+\.[0-9]+%)\s*(?:over|for)\s*(\d+) years?/gi;
          let percentYearMatch;
          while ((percentYearMatch = irrPercentYearRegex.exec(answerText)) !== null) {
            const key = percentYearMatch[1] + '_year_' + percentYearMatch[2];
            if (!seenIRR.has(key)) {
              irrValues.push({ irr: percentYearMatch[1], year: percentYearMatch[2], label: `Year ${percentYearMatch[2]}`, raw: percentYearMatch[0] });
              seenIRR.add(key);
            }
          }
          // Match decimal numbers but avoid using lookbehind/behind for compatibility
          const irrDecimalRegex = /([0-9]+\.[0-9]+)/g;
          let decimalMatch;
          while ((decimalMatch = irrDecimalRegex.exec(answerText)) !== null) {
            const key = decimalMatch[1];
            const idx = decimalMatch.index;
            const before = answerText[idx - 1] || '';
            const after = answerText[idx + decimalMatch[0].length] || '';
            // skip if adjacent to a digit or percent sign (to approximate word boundaries used earlier)
            if (/\d|%/.test(before) || /\d|%/.test(after)) continue;
            // Only add if not already captured with year or label
            if (!irrValues.some(v => v.irr === key && (v.year || v.label))) {
              if (!seenIRR.has(key)) {
                irrValues.push({ irr: key, raw: key });
                seenIRR.add(key);
              }
            }
          }
          // Overwrite localStorage with IRR values in answer order, no duplicates
          // Final deduplication: keep only the most specific entry for each IRR value
          const uniqueIRRs = {};
          irrValues.forEach(v => {
            const key = v.irr;
            // Prefer year/label over plain value
            if (!uniqueIRRs[key]) {
              uniqueIRRs[key] = v;
            } else {
              if ((v.year || v.label) && !uniqueIRRs[key].year && !uniqueIRRs[key].label) {
                uniqueIRRs[key] = v;
              }
            }
          });
          // Remove duplicate year entries
          const finalIRRs = Object.values(uniqueIRRs).filter((v, i, arr) => {
            if (v.year) {
              return arr.findIndex(x => x.year === v.year && x.irr === v.irr) === i;
            }
            return true;
          });
          // Persist price breakdowns first (enhanced parsing)
          try {
            // Load existing
            const priceBreakdowns = JSON.parse(localStorage.getItem('priceBreakdowns') || '[]');

            // 1) Plant-named total + calculated components (existing pattern)
            const pricePattern = /For\s+material\s+(\d+),\s*([^\(]+?)\s*\((PL\d+)\)\s*offers the lowest total per-unit cost at\s*\$?([0-9]+\.[0-9]+)/ig;
            let priceMatch;
            while ((priceMatch = pricePattern.exec(answerText)) !== null) {
              const material = priceMatch[1];
              const plantName = priceMatch[2].trim();
              const plantId = priceMatch[3];
              const totalCost = parseFloat(priceMatch[4]);
              const components = [];
              const calcMatch = /calculated as\s*([^\.]*)/i.exec(answerText);
              if (calcMatch && calcMatch[1]) {
                const parts = calcMatch[1].split('+').map(p => p.trim()).filter(Boolean);
                parts.forEach(p => {
                  const labeled = /([A-Za-z0-9 \-\/]+?)\s*\(\$?([0-9]+\.[0-9]+)\)/i.exec(p);
                  if (labeled) components.push({ label: labeled[1].trim(), value: parseFloat(labeled[2]) });
                  else {
                    const valOnly = /\$?([0-9]+\.[0-9]+)/.exec(p);
                    if (valOnly) components.push({ label: valOnly[1], value: parseFloat(valOnly[1]) });
                    else components.push({ label: p, value: null });
                  }
                });
              }
              // sanitize component labels and values (handle cases like 'Vendor Price ($1')
              const sanitizedComponents = components.map(c => {
                let lab = (c.label || '').trim();
                // extract numeric inside parentheses if present and value missing
                if ((c.value === null || c.value === undefined) && /\$?([0-9]+\.[0-9]+)/.test(lab)) {
                  const m = /\$?([0-9]+\.[0-9]+)/.exec(lab);
                  if (m) {
                    c.value = parseFloat(m[1]);
                    // remove the numeric portion and stray parentheses from label
                    lab = lab.replace(/\(?\$?[0-9]+\.[0-9]+\)?/g, '').trim();
                  }
                }
                // clean trailing punctuation
                lab = lab.replace(/[\(\),:\.]+$/g, '').trim();
                const val = (c.value !== null && c.value !== undefined) ? Number(c.value) : null;
                const unit = val !== null ? 'usd' : 'unknown';
                return { label: lab || String(val || ''), value: val, unit };
              });

              // avoid pushing duplicates: check for existing entry with same material+plantId+total+components signature
              const compSig = JSON.stringify(sanitizedComponents.map(x => ({label: x.label, value: x.value})));
              const exists = priceBreakdowns.find(pb => pb.material === material && pb.plantId === plantId && Number(pb.totalCost) === Number(totalCost) && JSON.stringify((pb.components||[]).map(x=>({label:x.label,value:x.value}))) === compSig);
              if (!exists) priceBreakdowns.push({ material, plantName, plantId, totalCost, components: sanitizedComponents, timestamp: Date.now() });
            }

            // 2) Component-only per-material sentences, including multi-material lists and raw material cost units (INR/ton)
            // Examples handled:
            // "For material 100001, 100002, and 100003, the production cost is 363.526..."
            // "The Cost Of Production is 34585.5359."
            // "Raw material costs include RSMM rock at 5722.2222 INR/ton and Jordan rock at 8808.2840 INR/ton."
            const materialListPattern = /For\s+material[s]?\s+((?:\d+\s*(?:,|and)?\s*)+),\s*([^\.]*)(?:\.|$)/ig;
            let listMatch;
            while ((listMatch = materialListPattern.exec(answerText)) !== null) {
              const matsRaw = listMatch[1];
              const sentence = listMatch[2];
              const materials = matsRaw.split(/(?:,|\band\b)/i).map(s => s.trim()).filter(Boolean);
              // Known component label patterns (monetary)
              const compRegex = /(production cost|vendor price|transport cost|holding cost|production|vendor|transport|holding|vendor cost|cost of production)\s*(?:is|:|=)?\s*\$?([0-9]+(?:\.[0-9]+)?)/ig;
              const compLabelRegex = /([A-Za-z0-9 \-]{3,60}?)\s*(?:is|:|=)?\s*\$?([0-9]+(?:\.[0-9]+)?)/ig;
              // Raw material INR/ton pattern
              const rawMatRegex = /([A-Za-z0-9 \-]+?)\s+at\s+([0-9]+(?:\.[0-9]+)?)\s*INR\/ton/ig;
              const components = [];
              let foundAny = false;
              let mMatch;
              // first, explicit known labels
              while ((mMatch = compRegex.exec(sentence)) !== null) {
                let rawLabel = (mMatch[1] || 'Component').trim();
                const value = parseFloat(mMatch[2]);
                rawLabel = rawLabel.replace(/^production$/i, 'Production Cost')
                                     .replace(/^vendor$/i, 'Vendor Price')
                                     .replace(/^transport$/i, 'Transport Cost')
                                     .replace(/^holding$/i, 'Holding Cost')
                                     .replace(/vendor cost/i, 'Vendor Price')
                                     .replace(/cost of production/i, 'Cost Of Production');
                components.push({ label: capitalizeLabel(rawLabel), value, unit: 'usd' });
                foundAny = true;
              }
              // next, raw material INR/ton entries
              while ((mMatch = rawMatRegex.exec(sentence)) !== null) {
                const rawLabel = (mMatch[1] || '').trim();
                const value = parseFloat(mMatch[2]);
                if (rawLabel) {
                  components.push({ label: capitalizeLabel(rawLabel), value, unit: 'inr_per_ton' });
                  foundAny = true;
                }
              }
              // fallback generic extraction only if labels present (do not invent labels)
              if (!foundAny) {
                let gMatch;
                while ((gMatch = compLabelRegex.exec(sentence)) !== null) {
                  const rawLabel = (gMatch[1] || '').trim();
                  const val = parseFloat(gMatch[2]);
                  // Only accept if rawLabel appears reasonably like a label (contains letters)
                  if (/[A-Za-z]/.test(rawLabel)) {
                    components.push({ label: capitalizeLabel(rawLabel), value: val, unit: 'usd' });
                    foundAny = true;
                  }
                }
              }
              if (foundAny && components.length) {
                // compute totalCost only if sentence explicitly gives an aggregate or if components can be summed
                const sum = components.reduce((s, c) => s + (c.value || 0), 0);
                const maybeTotal = /(?:total cost|cost of production|total per-unit cost|total cost is)\s*(?:is|:|=)?\s*\$?([0-9]+(?:\.[0-9]+)?)/i.exec(sentence);
                const totalCost = maybeTotal ? parseFloat(maybeTotal[1]) : (sum || null);
                // push an entry per material found
                materials.forEach(material => {
                  const sanitizedComponents = components.map(c => ({ label: (c.label||'').replace(/[\(\),:\.]+$/g,'').trim(), value: (c.value !== null && c.value !== undefined) ? Number(c.value) : null, unit: c.unit || (c.value !== null ? 'usd' : 'unknown') }));
                  const compSig = JSON.stringify(sanitizedComponents.map(x => ({label: x.label, value: x.value, unit: x.unit})));
                  const exists = priceBreakdowns.find(pb => pb.material === material && JSON.stringify((pb.components||[]).map(x=>({label:x.label,value:x.value,unit:x.unit}))) === compSig);
                  if (!exists) priceBreakdowns.push({ material, plantName: '', plantId: '', totalCost, components: sanitizedComponents, timestamp: Date.now() });
                });
              }
            }

            // single-material fallback (existing behavior)
            const materialSentencePattern = /For\s+material\s+(\d+),\s*([^\.]*)(?:\.|$)/ig;
            let matMatch;
            while ((matMatch = materialSentencePattern.exec(answerText)) !== null) {
              const material = matMatch[1];
              const sentence = matMatch[2];
              // find all label/value pairs inside the sentence
              // First try explicit known component labels like 'production cost' or 'vendor price'
              const compRegex = /(production cost|vendor price|transport cost|holding cost|production|vendor|transport|holding|vendor cost)\s*(?:is|:|=)?\s*\$?([0-9]+\.[0-9]+)/ig;
              const compLabelRegex = /([A-Za-z ]{3,40}?)\s*(?:is|:|=)?\s*\$?([0-9]+\.[0-9]+)/ig;
              const components = [];
              let foundAny = false;
              let cMatch;
              while ((cMatch = compRegex.exec(sentence)) !== null) {
                let rawLabel = (cMatch[1] || 'Component').trim();
                const value = parseFloat(cMatch[2]);
                // normalize common short forms to canonical labels
                rawLabel = rawLabel.replace(/^production$/i, 'Production Cost')
                                     .replace(/^vendor$/i, 'Vendor Price')
                                     .replace(/^transport$/i, 'Transport Cost')
                                     .replace(/^holding$/i, 'Holding Cost')
                                     .replace(/vendor cost/i, 'Vendor Price');
                components.push({ label: capitalizeLabel(rawLabel), value });
                foundAny = true;
              }
              // fallback generic extraction of "Label $x.xx" pairs
              if (!foundAny) {
                while ((cMatch = compLabelRegex.exec(sentence)) !== null) {
                  const rawLabel = (cMatch[1] || 'Component').trim();
                  const value = parseFloat(cMatch[2]);
                  // only accept if rawLabel contains letters (avoid bare numbers)
                  if (/[A-Za-z]/.test(rawLabel)) {
                    components.push({ label: capitalizeLabel(rawLabel), value });
                    foundAny = true;
                  }
                }
              }
              if (foundAny) {
                const totalCost = components.reduce((s, c) => s + (c.value || 0), 0);
                  // sanitize components similar to above
                  const sanitizedComponents = components.map(c => {
                    const lab = (c.label||'').replace(/[\(\),:\.]+$/g,'').trim() || String(c.value || '');
                    const val = (c.value !== null && c.value !== undefined) ? Number(c.value) : null;
                    const unit = val !== null ? 'usd' : 'unknown';
                    return { label: lab, value: val, unit };
                  });
                  const compSig = JSON.stringify(sanitizedComponents.map(x => ({label: x.label, value: x.value})));
                  const exists = priceBreakdowns.find(pb => pb.material === material && (!pb.plantId || pb.plantId === '') && JSON.stringify((pb.components||[]).map(x=>({label:x.label,value:x.value}))) === compSig);
                  if (!exists) priceBreakdowns.push({ material, plantName: '', plantId: '', totalCost, components: sanitizedComponents, timestamp: Date.now() });
              }
            }

            // final cleanup: dedupe by material+plantId+total+components signature
            const cleaned = [];
            const seenSigs = new Set();
            priceBreakdowns.forEach(pb => {
              const sig = JSON.stringify({ material: pb.material, plantId: pb.plantId || '', total: Number(pb.totalCost || 0), comps: (pb.components||[]).map(c=>({label:c.label,value:c.value})) });
              if (!seenSigs.has(sig)) {
                seenSigs.add(sig);
                cleaned.push(pb);
              }
            });
            // remove empty-component entries if a total exists for same material+plantId (prefer entries with components)
            const finalList = [];
            const totalsIndex = {};
            cleaned.forEach(pb => {
              const key = `${pb.material}::${pb.plantId || ''}::${Number(pb.totalCost || 0)}`;
              if ((pb.components||[]).length) {
                totalsIndex[key] = true;
                finalList.push(pb);
              } else {
                // keep only if no component-bearing entry exists for same key
                if (!totalsIndex[key]) finalList.push(pb);
              }
            });
            localStorage.setItem('priceBreakdowns', JSON.stringify(finalList));
            try {
              const dashboardFrame = window.parent.document.querySelector('iframe[src="dashboard.html"]');
              if (dashboardFrame) dashboardFrame.contentWindow.postMessage({ type: 'priceBreakdowns', data: JSON.parse(localStorage.getItem('priceBreakdowns') || '[]') }, '*');
            } catch (e) { /* silent */ }
          } catch (e) {
            console.error('Price breakdown parse error', e);
          }

          // Persist all parsed IRR values (do not filter numeric-only entries here)
          try {
            // Attach 'unit' metadata: percent if token contains '%', or context implies IRR, else 'number'
            const annotated = finalIRRs.map(v => {
              try {
                const raw = (typeof v === 'object' && v !== null) ? (v.raw || v.irr || '') : String(v);
                // Check context: prefer percent if answer mentions IRR/percent or label suggests a rate
                const lowercaseAnswer = String(answerText || '').toLowerCase();
                const contextIndicatesIRR = /\birr\b/i.test(answerText) || /internal rate of return/i.test(lowercaseAnswer) || /%/.test(lowercaseAnswer) || /rate\b/.test(lowercaseAnswer);
                let unit = 'number';
                const numericVal = parseFloat(String(raw));
                // Explicit percent token wins
                if (/%/.test(String(raw))) {
                  unit = 'percent';
                } else if (/irr/i.test(String(v.label || '')) || /rate/i.test(String(v.label || ''))) {
                  // labeled IRR/rate entries are percent-like. Accept larger-than-1 values too (e.g., '17%')
                  unit = 'percent';
                } else if (contextIndicatesIRR) {
                  // If answer context mentions IRR or percent, treat reasonable numeric tokens as percent.
                  // Heuristic: if numeric value is between 0 (exclusive) and 100 (exclusive), consider percent.
                  if (!isNaN(numericVal) && numericVal > 0 && numericVal < 100) {
                    // Prefer percent for small decimals (<5) or values that look like percentages (>1)
                    if (numericVal < 5 || numericVal > 1) unit = 'percent';
                  }
                } else if (!isNaN(numericVal) && Math.abs(numericVal) < 1) {
                  // fallback: small decimals are likely percent/ratio
                  unit = 'percent';
                }
                return Object.assign({}, v, { unit });
              } catch (e) { return v; }
            });
            localStorage.setItem('irrValues', JSON.stringify(annotated));
            try {
              const dashboardFrame = window.parent.document.querySelector('iframe[src="dashboard.html"]');
              if (dashboardFrame) dashboardFrame.contentWindow.postMessage({ type: 'irrData', data: annotated }, '*');
            } catch (e) { /* silent */ }
          } catch (e) {
            console.error('Failed to persist irrValues', e);
          }
          let citeHtml = '';
          if(answerText){
            answerRegion.innerHTML = `
              <div class="answer-card">
                 <span class="badge">Answer</span>
                 <div class="answer-body">${escapeHtml(answerText)}</div>
                 ${citeHtml}
              </div>`;
          } else {
            answerRegion.innerHTML = '<p class="error-text">No answer returned.</p>';
          }
          // citation UI and blocks removed per request
          // Related questions chips
          if(Array.isArray(data?.answer?.relatedQuestions)){
            relatedWrap.innerHTML = '';
            data.answer.relatedQuestions.forEach(q => {
              const chip = document.createElement('button');
              chip.className='chip';
              chip.textContent=q;
              chip.onclick=()=>{ input.value=q; callApi(q); };
              relatedWrap.appendChild(chip);
            });
          }
        } catch (err) {
          console.error('API error:', err);
          answerRegion.innerHTML = '<p class="error-text">Error fetching answer.</p>';
        } finally {
          setLoading(false);
        }
      }
      btn.addEventListener('click', () => callApi(input.value.trim()));
      input.addEventListener('keydown', (e) => { if(e.key === 'Enter') callApi(input.value.trim()); });

      // Expose a way to inject token dynamically from parent (index.html) via postMessage
      window.addEventListener('message', (evt) => {
        if(!evt.data) return;
        if(evt.data.type === 'googleAccessToken'){
          bearerToken = evt.data.token;
          localStorage.setItem('searchAuthToken', bearerToken);
          console.log('Access token updated for API calls');
          tokenStatus.textContent = 'Auth: token received';
          btn.disabled = false;
        } else if(evt.data.type === 'firebaseLogin') {
          // Firebase ID token received (not directly usable for Discovery Engine REST)
          tokenStatus.textContent = 'Auth: firebase session active (waiting access token)';
        }
      });

      // Safety: after 5s if no token, remind user
      setTimeout(() => {
        if(!tokenAvailable()){
          tokenStatus.textContent = 'Auth: still waiting for Google access token. Please login again.';
        }
      }, 5000);

      // Utility to escape HTML
      function escapeHtml(str){
        return str.replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;','\'':'&#39;'}[c]));
      }

      // Helper to normalize/capitalize component labels
      function capitalizeLabel(s){
        if(!s) return '';
        return String(s).trim().split(/\s+/).map(w => w.charAt(0).toUpperCase() + w.slice(1).toLowerCase()).join(' ');
      }
    })();
  </script>
 
</body>

</html>