<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title> Dashboard</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    body {
      background: linear-gradient(180deg,#0f172a 0%, #071129 55%);
      color: #e6eef8;
      font-family: sans-serif;
      min-height: 100vh;
      padding: 2rem;
    }
    .glass {
      background: linear-gradient(135deg, rgba(255,255,255,0.04), rgba(255,255,255,0.02));
      backdrop-filter: blur(6px);
      border: 1px solid rgba(255,255,255,0.06);
      border-radius: 0.75rem;
      padding: 1rem;
    }
    .metric-list li {
      margin-bottom: 0.5rem;
    }
  </style>
</head>
<body>
  <main class="max-w-5xl mx-auto space-y-8">
    <header class="flex flex-col md:flex-row md:items-center md:justify-between text-center md:text-left">
      <div>
        <h1 id="dashboardTitle" class="text-4xl font-bold tracking-tight transition-all duration-300"> Dashboard</h1>
        <p id="dashboardSubtitle" class="text-slate-300 mt-2 text-lg"> data overview</p>
      </div>
      <div class="flex gap-4 justify-center md:justify-end mt-4 md:mt-0">
        <button id="downloadPdfBtn" title="Download PDF" class="bg-white/10 hover:bg-blue-600 text-blue-300 hover:text-white rounded-full p-3 shadow-lg transition-all flex items-center gap-2">
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-file-text"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/><polyline points="14 2 14 8 20 8"/><line x1="16" y1="13" x2="8" y2="13"/><line x1="16" y1="17" x2="8" y2="17"/><polyline points="10 9 9 9 8 9"/></svg>
          <span class="hidden md:inline">Download PDF</span>
        </button>
        <button id="pushBiBtn" title="Push BI Dashboard" class="bg-white/10 hover:bg-green-600 text-green-300 hover:text-white rounded-full p-3 shadow-lg transition-all flex items-center gap-2">
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-monitor"><rect x="2" y="7" width="20" height="15" rx="2" ry="2"/><polyline points="17 2 12 7 7 2"/></svg>
          <span class="hidden md:inline">Push BI Dashboard</span>
        </button>
        <button id="previewPdfBtn" title="Preview PDF" class="bg-white/10 hover:bg-sky-600 text-sky-300 hover:text-white rounded-full p-3 shadow-lg transition-all flex items-center gap-2">
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-eye"><path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8S1 12 1 12z"/><circle cx="12" cy="12" r="3"/></svg>
          <span class="hidden md:inline">Preview</span>
        </button>
        <button id="shareBtnSimple" title="Share PDF" class="bg-white/10 hover:bg-indigo-600 text-indigo-300 hover:text-white rounded-full p-3 shadow-lg transition-all flex items-center gap-2">
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-share-2"><path d="M4 12v7a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2v-7"/><polyline points="16 6 12 2 8 6"/><line x1="12" y1="2" x2="12" y2="15"/></svg>
          <span class="hidden md:inline">Share</span>
        </button>
        
      </div>
    </header>
    <!-- Developer debug panel (press 'D' to toggle) -->
    <div id="devMatchPanel" style="position:fixed;left:1rem;bottom:1rem;background:rgba(0,0,0,0.6);color:#e6eef8;padding:8px;border-radius:8px;display:none;z-index:9999;max-width:420px;">
      <div style="display:flex;gap:8px;align-items:center;">
        <button id="dumpMatchesBtn" style="background:#111827;color:#fff;padding:6px 10px;border-radius:6px;border:none;cursor:pointer;">Dump Matches</button>
        <button id="closeDevPanel" style="background:transparent;border:1px solid rgba(255,255,255,0.06);color:#e6eef8;padding:6px 8px;border-radius:6px;">Close</button>
      </div>
      <div id="devMatchOutput" style="margin-top:8px;max-height:260px;overflow:auto;font-size:12px;line-height:1.3;color:#cbd5e1;"></div>
    </div>

  

    <section class="grid grid-cols-1 md:grid-cols-2 gap-8">
      <div class="glass flex flex-col gap-4">
        <h2 class="text-sm text-slate-300 mb-2"> Key Metrics</h2>
        <div id="irrMetricCards" class="grid grid-cols-2 gap-4"></div>
        <div id="valueMappingSection" class="mt-3 text-sm text-slate-300"></div>
        <div>
          <h3 class="text-sm text-slate-300 mb-2">Extra Metrics</h3>
          <div id="extraMetricCards" class="grid grid-cols-2 gap-4"></div>
        </div>
      </div>
      <div class="glass flex flex-col gap-4">
        <h3 class="text-sm text-slate-300 mb-2">Summary Table <span class="text-xs text-blue-300">(click to sort)</span></h3>
        <table class="w-full text-left border-collapse border border-white/20" id="irrTable">
          <thead>
            <tr>
              <th class="border border-white/20 px-4 py-2 cursor-pointer" id="sortLabel">Label/Year</th>
               <th class="border border-white/20 px-4 py-2 cursor-pointer" id="sortIRR">Value (%)</th>
            </tr>
          </thead>
          <tbody></tbody>
        </table>
        <div class="mt-2 text-xs text-slate-400" id="lastUpdated"></div>
      </div>
    </section>

    <section class="grid grid-cols-1 md:grid-cols-3 gap-6 mt-6">
      <div class="glass card col-span-1 md:col-span-3 animate-fadein">
          <h3 class="text-lg mb-3">  Bar Chart</h3>
        <canvas id="irrRadarChart"></canvas>
      </div>
      <div class="glass card col-span-1 animate-fadein">
          <h3 class="text-lg mb-3">  Line Chart</h3>
        <canvas id="irrLineChart"></canvas>
      </div>
      <div class="glass card col-span-1 animate-fadein">
          <h3 class="text-lg mb-3">  Donut Chart</h3>
        <canvas id="irrDonutChart"></canvas>
      </div>
    </section>

    
  </main>

  <script>

  // Developer flags


    // Make webhook constants (client-side send)
    const MAKE_WEBHOOK_URL = "https://hook.eu2.make.com/w74s2h3fbypn8e7x6i7msitnx17ybglb";
    const MAKE_API_KEY = "super-secret-12345";

    // cached PDF blob to avoid re-generating multiple times
    let cachedPdfBlob = null;
    // Price breakdowns, headers and vendor sections are visible by default.
    async function ensurePdfBlob() {
      if (cachedPdfBlob) return cachedPdfBlob;
      // generate PDF using html2pdf and return a Blob
      await import('https://cdnjs.cloudflare.com/ajax/libs/html2pdf.js/0.10.1/html2pdf.bundle.min.js');
      const opt = { margin: 0.5, filename: 'dashboard.pdf', image: { type: 'jpeg', quality: 0.98 }, html2canvas: { scale: 2 }, jsPDF: { unit: 'in', format: 'a4', orientation: 'portrait' } };
      // html2pdf returns a promise via node.js style; we convert to a Blob via output('blob')
      return new Promise((resolve, reject) => {
        try {
          html2pdf().set(opt).from(document.body).output('blob').then(blob => {
            cachedPdfBlob = blob;
            resolve(blob);
          }).catch(reject);
        } catch (e) { reject(e); }
      });
    }

    // Render explicit mapping of Value N -> numeric value -> matched label
    function renderValueMappings(irrData) {
      const container = document.getElementById('valueMappingSection');
      if (!irrData || !irrData.length) { container.innerHTML = ''; return; }
      // Use existing getMatchedLabelForValue to map
      const rows = irrData.map((d, i) => {
        const raw = (typeof d === 'object' && d !== null) ? d.irr : d;
  const matched = typeof getMatchedLabelForValue === 'function' ? getMatchedLabelForValue(raw, i) : null;
        // Determine token unit (prefer explicit unit on the entry)
        const tokenUnit = (typeof d === 'object' && d !== null && d.unit) ? d.unit : (String(raw).includes('%') ? 'percent' : 'number');
        let matchedText = '';
        if (matched && tokenUnit !== 'percent') {
          if (matched.type === 'component') matchedText = matched.label;
          else if (matched.type === 'total') matchedText = `${matched.plantId || ''} ${matched.plantName || ''}`.trim() + (matched.isLowest ? ' (Lowest)' : '');
        }
        const displayRaw = tokenUnit === 'percent' ? (Number(String(raw).match(/([0-9]+(?:\.[0-9]+)?)/)?.[1] || raw).toFixed(4) + '%') : String(raw);
        return `<div class="flex justify-between"><div>Value ${i+1}</div><div class="font-mono">${escapeHtml(displayRaw)}</div><div class="text-slate-300">${escapeHtml(matchedText)}</div></div>`;
      }).join('<hr/>');
      container.innerHTML = rows;
    }

    // simple HTML escape helper
    function escapeHtml(str) {
      if (str === null || str === undefined) return '';
      return String(str)
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#39;');
    }

    

    // Simple Share modal (insert near other modal logic)
    const simpleShareModalHtml = `
      <div id="simpleShareModal" class="fixed inset-0 bg-black/50 hidden items-center justify-center">
        <div class="bg-white/5 p-6 rounded shadow-lg w-full max-w-lg glass">
          <h3 class="text-xl mb-2">Share Dashboard (PDF)</h3>
          <div class="space-y-2">
            <label class="block text-sm">To (comma-separated)</label>
            <input id="simpleTo" class="w-full p-2 rounded bg-white/5" />
            <label class="block text-sm">CC (optional)</label>
            <input id="simpleCc" class="w-full p-2 rounded bg-white/5" />
            <label class="block text-sm">Subject</label>
            <input id="simpleSubject" class="w-full p-2 rounded bg-white/5" value="Shared Dashboard" />
            <div id="simpleShareStatus" class="text-sm text-yellow-300"></div>
            <div class="flex justify-end gap-2 mt-4">
              <button id="simpleShareCancel" class="px-4 py-2 rounded bg-gray-600">Cancel</button>
              <button id="simpleShareSend" class="px-4 py-2 rounded bg-indigo-600 text-white">Send</button>
            </div>
          </div>
        </div>
      </div>
    `;
    document.body.insertAdjacentHTML('beforeend', simpleShareModalHtml);
    const simpleShareModal = document.getElementById('simpleShareModal');
    const simpleTo = document.getElementById('simpleTo');
    const simpleCc = document.getElementById('simpleCc');
    const simpleSubject = document.getElementById('simpleSubject');
    const simpleShareStatus = document.getElementById('simpleShareStatus');
    const simpleShareSend = document.getElementById('simpleShareSend');
    const simpleShareCancel = document.getElementById('simpleShareCancel');

    document.getElementById('shareBtnSimple').addEventListener('click', () => {
      simpleShareModal.classList.remove('hidden'); simpleShareModal.classList.add('flex');
      simpleShareStatus.textContent = '';
    });
    simpleShareCancel.addEventListener('click', () => { simpleShareModal.classList.remove('flex'); simpleShareModal.classList.add('hidden'); });

    

    simpleShareSend.addEventListener('click', async () => {
      simpleShareStatus.textContent = 'Preparing PDF...';
      try {
        const blob = await ensurePdfBlob();
        if (!blob) throw new Error('Failed to generate PDF');
        simpleShareStatus.textContent = 'Uploading to Make...';
        const form = new FormData();
        form.append('dashboard', blob, 'dashboard.pdf');
        form.append('to', simpleTo.value || '');
        form.append('cc', simpleCc.value || '');
        form.append('subject', simpleSubject.value || 'Shared Dashboard');

        const headers = { 'x-make-apikey': MAKE_API_KEY };
        const resp = await fetch(MAKE_WEBHOOK_URL, { method: 'POST', headers, body: form });
        const text = await resp.text();
        if (resp.ok) {
          simpleShareStatus.textContent = 'Shared via Make webhook.';
          setTimeout(() => { simpleShareModal.classList.remove('flex'); simpleShareModal.classList.add('hidden'); }, 1200);
        } else {
          simpleShareStatus.textContent = 'Make webhook failed: ' + (text || resp.statusText);
        }
      } catch (e) {
        console.error('Share failed', e);
        simpleShareStatus.textContent = 'Share failed: ' + (e && e.message ? e.message : e);
      }
    });

    // Preview modal (shows cached PDF and allows download/share)
    const previewHtml = `
      <div id="previewModal" class="fixed inset-0 bg-black/50 hidden items-center justify-center">
        <div class="bg-white/5 p-4 rounded shadow-lg w-full max-w-4xl glass">
          <div class="flex justify-between items-center mb-2">
            <h3 class="text-lg">PDF Preview</h3>
            <div class="flex gap-2">
              <button id="previewDownload" class="px-3 py-1 rounded bg-white/10">Download</button>
              <button id="previewShare" class="px-3 py-1 rounded bg-indigo-600 text-white">Share</button>
              <button id="previewClose" class="px-3 py-1 rounded bg-gray-600">Close</button>
            </div>
          </div>
          <div style="height:70vh;">
            <object id="pdfPreviewObject" type="application/pdf" width="100%" height="100%">Your browser does not support inline PDF preview.</object>
          </div>
        </div>
      </div>
    `;
    document.body.insertAdjacentHTML('beforeend', previewHtml);
    const previewModal = document.getElementById('previewModal');
    const pdfPreviewObject = document.getElementById('pdfPreviewObject');
    const previewDownload = document.getElementById('previewDownload');
    const previewShare = document.getElementById('previewShare');
    const previewClose = document.getElementById('previewClose');

    document.getElementById('previewPdfBtn').addEventListener('click', async () => {
      previewModal.classList.remove('hidden'); previewModal.classList.add('flex');
      try {
        const blob = await ensurePdfBlob();
        const url = URL.createObjectURL(blob);
        pdfPreviewObject.data = url;
        // set download link
        previewDownload.onclick = () => { const a = document.createElement('a'); a.href = url; a.download = 'dashboard.pdf'; document.body.appendChild(a); a.click(); a.remove(); };
        // share opens the simple share modal and ensures the pdf is cached
        previewShare.onclick = () => { simpleShareModal.classList.remove('hidden'); simpleShareModal.classList.add('flex'); simpleShareStatus.textContent = ''; };
      } catch (e) {
        console.error('Preview failed', e);
      }
    });
    previewClose.addEventListener('click', () => { previewModal.classList.remove('flex'); previewModal.classList.add('hidden'); });


    // PDF download logic
    document.addEventListener('DOMContentLoaded', function() {
      const pdfBtn = document.getElementById('downloadPdfBtn');
      if (pdfBtn) {
        pdfBtn.addEventListener('click', function() {
          import('https://cdnjs.cloudflare.com/ajax/libs/html2pdf.js/0.10.1/html2pdf.bundle.min.js').then(() => {
            html2pdf(document.body, {
              margin: 0.5,
              filename: 'dashboard.pdf',
              image: { type: 'jpeg', quality: 0.98 },
              html2canvas: { scale: 2 },
              jsPDF: { unit: 'in', format: 'a4', orientation: 'portrait' }
            });
          });
        });
      }
      // Push BI Dashboard logic (fullscreen)
      const biBtn = document.getElementById('pushBiBtn');
      if (biBtn) {
        biBtn.addEventListener('click', function() {
          if (!document.fullscreenElement) {
            document.documentElement.requestFullscreen();
          } else {
            document.exitFullscreen();
          }
        });
      }
    });

  let radarChart, lineChart, donutChart;
    const colors = ["#60a5fa","#f472b6","#34d399","#facc15","#a78bfa","#fb7185","#38bdf8","#fbbf24","#a3e635","#f87171"];
    function renderDashboard(irrData) {
      // Dynamic title/subtitle
      const titleEl = document.getElementById('dashboardTitle');
      const subtitleEl = document.getElementById('dashboardSubtitle');
      let title = 'Dashboard';
      let subtitle = ' data overview';
      if (irrData.some(d => d.label && d.label.toLowerCase().includes('lead silver recovery'))) {
        title = 'Lead Silver Recovery Project ';
        subtitle = 'Varying  for Lead Silver Recovery';
      } else if (irrData.some(d => d.label && d.label.toLowerCase().includes('fumer'))) {
        title = 'Fumer Project ';
        subtitle = ' for Fumer Technology';
      } else if (irrData.some(d => d.year)) {
        title = 'STL  Over Years';
        subtitle = 'Year-wise breakdown';
      }
      titleEl.textContent = title;
      subtitleEl.textContent = subtitle;

      // Animated metric cards for IRR values
      const irrMetricCards = document.getElementById('irrMetricCards');
  // Load price breakdowns (if present) to attach component labels to numeric values where possible.
  // Note: price breakdown UI is removed, but reading this allows matching labels for Key Metrics.
  let pbList = [];
  try { pbList = JSON.parse(localStorage.getItem('priceBreakdowns') || '[]'); } catch (e) { pbList = []; }
  // Conservative convenience: if stored irrValues contain percent-like entries
  // that numerically match monetary values in priceBreakdowns, convert them to
  // unit 'usd' so the dashboard displays them as dollar values. This helps when
  // assistant text accidentally annotated money with '%'. We only convert when
  // there's a clear numeric match to avoid misinterpreting genuine percent rates.
  try {
    const irrStored = JSON.parse(localStorage.getItem('irrValues') || '[]');
    if (Array.isArray(irrStored) && irrStored.length && Array.isArray(pbList) && pbList.length) {
      const EPS2 = 1e-6;
      // collect monetary candidates from pbList
      const monetaryVals = [];
      pbList.forEach(e => {
        if (e && e.totalCost !== null && e.totalCost !== undefined) monetaryVals.push(Number(e.totalCost));
        (e.components || []).forEach(c => { if (c && c.value !== null && c.value !== undefined) monetaryVals.push(Number(c.value)); });
      });
      let changed = false;
      irrStored.forEach((entry, idx) => {
        try {
          const raw = String((entry && (entry.raw || entry.irr)) || '');
          // robust percent-like detection: raw contains '%', or stored unit indicates percent,
          // or irr/raw fields contain '%' even if raw didn't (some parsers normalize differently)
          const unit = entry && entry.unit ? String(entry.unit).toLowerCase() : '';
          const looksLikePercent = /%/.test(raw) || /%/.test(String(entry && entry.irr || '')) || unit === 'percent' || unit === '%';
          if (!looksLikePercent) return; // only convert percent-like entries
          const m = String(entry && entry.irr || raw).match(/([0-9]+(?:\.[0-9]+)?)/);
          if (!m) return;
          const num = Number(m[1]);
          if (isNaN(num)) return;
          // Try to find a matching component object (not just the numeric value) so we can inherit its label
          const matchComp = (function(){
            for (const e of pbList) {
              if (e && e.totalCost !== null && e.totalCost !== undefined && Math.abs(Number(e.totalCost) - num) < EPS2) {
                return { label: `Total (${e.plantName || e.plantId || ''})`, source: e.source || null };
              }
              for (const c of (e.components || [])) {
                if (c && c.value !== null && c.value !== undefined && Math.abs(Number(c.value) - num) < EPS2) {
                  return { label: c.label || String(c.value), source: c.source || null };
                }
              }
            }
            return null;
          })();
          if (matchComp) {
            entry.unit = 'usd';
            entry.irr = Number(num).toFixed(2);
            entry.raw = entry.irr;
            entry.source = entry.source || 'fixed-by-dashboard';
            // attach label if found
            if (matchComp.label) entry.label = entry.label || matchComp.label;
            if (matchComp.source) entry.source = entry.source || matchComp.source;
            changed = true;
          }
        } catch (e) { /* ignore per-entry errors */ }
      });
      if (changed) localStorage.setItem('irrValues', JSON.stringify(irrStored));
    }
  } catch (e) { /* non-fatal */ }
      // Flatten components for quick numeric matching with metadata: [{value, label, type, plantId, plantName, material}]
      const pbComponents = [];
      const lowestTotalByMaterial = {};
      // Canonical label map to normalize synonyms coming from widget parsing
      const canonicalMap = {
        'production cost': 'Production Cost',
        'production': 'Production Cost',
        'vendor price': 'Vendor Price',
        'vendor': 'Vendor Price',
        'transport cost': 'Transport Cost',
        'transport': 'Transport Cost',
        'holding cost': 'Holding Cost',
        'holding': 'Holding Cost'
      };

      pbList.forEach(entry => {
        const material = entry.material || '';
        const plantId = entry.plantId || '';
        const plantName = entry.plantName || '';
        const totalVal = (entry.totalCost !== null && entry.totalCost !== undefined) ? Number(entry.totalCost) : null;
        if (totalVal !== null) {
          pbComponents.push({ value: totalVal, label: `Total (${plantName || plantId})`, type: 'total', plantId, plantName, material });
          if (typeof lowestTotalByMaterial[material] === 'undefined' || totalVal < lowestTotalByMaterial[material]) {
            lowestTotalByMaterial[material] = totalVal;
          }
        }
        (entry.components || []).forEach(c => {
          if (c && (c.value !== null && c.value !== undefined)) {
            // preserve assistant-provided labels when present. Only apply canonicalMap
            // when the original label exactly matches a known ambiguous key (e.g. 'production').
            let lab = (c.label || String(c.value)).trim();
            const key = String(lab).toLowerCase();
            // apply canonical mapping only when the original label exactly equals a canonical key
            if ((!c.label || String(c.label).trim() === '') && canonicalMap[key]) {
              lab = canonicalMap[key];
            } else if (canonicalMap[key] && String(c.label || '').trim().toLowerCase() === key) {
              lab = canonicalMap[key];
            }
            const unit = c.unit || 'usd';
            // preserve source (e.g., 'paired') from widget parsing when present
            const src = c.source || null;
            pbComponents.push({ value: Number(c.value), label: lab, type: 'component', plantId, plantName, material, unit, source: src });
          }
        });
      });
      // Heuristic normalization: if a plant has multiple components all labeled 'Production Cost'
      // but also has a Vendor Price and a Total, try to infer Transport/Holding labels for the
      // smaller duplicate components. This is conservative and only runs when vendor and total exist.
      try {
        const byPlant = {};
        pbComponents.forEach(c => {
          const pid = (c.plantId || c.plantName || '').trim();
          byPlant[pid] = byPlant[pid] || [];
          byPlant[pid].push(c);
        });
        Object.keys(byPlant).forEach(pid => {
          const comps = byPlant[pid];
          const vendor = comps.find(x => x.label && x.label.toLowerCase().includes('vendor'));
          const total = comps.find(x => x.type === 'total');
          if (!vendor || !total) return; // need both to run
          // find components labeled production cost
          const prodCandidates = comps.filter(x => x.type === 'component' && x.label && x.label.toLowerCase().includes('production'));
          if (prodCandidates.length < 2) return;
          // sort by descending value and keep the largest as production; reassign next as transport, then holding
          const sorted = prodCandidates.slice().filter(x => !isNaN(x.value)).sort((a,b) => b.value - a.value);
          if (sorted.length < 2) return;
          // conservative guard: ensure values look small relative to total (avoid relabeling large entries)
          const relGuard = (v) => (Math.abs(v) <= Math.max(1, Math.abs(total.value) * 0.25));
          // assign labels to 2 smaller ones if they pass guard
          for (let i = 1; i < Math.min(sorted.length, 3); i++) {
            const c = sorted[i];
            if (!c || isNaN(c.value)) continue;
            if (!relGuard(c.value)) continue;
            if (i === 1) c.label = 'Transport Cost';
            else if (i === 2) c.label = 'Holding Cost';
            c.source = c.source || 'inferred';
          }
        });
      } catch (e) { /* non-fatal */ }
      // Count how many 'paired' signals each plant+material has. We'll prefer
      // components coming from plants with more paired evidence when resolving
      // ambiguous matches (tie-breaker).
      const pairedCountByPlantMaterial = {};
      pbComponents.forEach(c => {
        try {
          if (c && c.source === 'paired') {
            const pid = (c.plantId || c.plantName || '').trim();
            const key = `${c.material}||${pid}`;
            pairedCountByPlantMaterial[key] = (pairedCountByPlantMaterial[key] || 0) + 1;
          }
        } catch (e) { /* ignore per-comp */ }
      });

      const EPS = 1e-6;
      // Build a one-to-one greedy pairing between visible numeric values and component values
      // Greedy nearest-unused-component: for each visible numeric value (in any order), pick the closest unused component
      const valueToComponentMap = (function buildPairing(irrList, comps){
        // Global minimal-diff greedy matching:
        // 1) build list of numeric visible values and component candidates
        // 2) compute all pair diffs (abs difference)
        // 3) sort pairs by diff asc
        // 4) greedily assign lowest-diff pairs while enforcing one-to-one mapping
        const map = {};
        try {
          const numericValues = [];
          irrList.forEach((d,i) => {
            const raw = (typeof d === 'object' && d !== null) ? d.irr : d;
            const rawStr = String(raw || '');
            // detect percent-like tokens: explicit '%' or labeled IRR entries in stored irrValues
            let looksLikePercent = /%/.test(rawStr);
            if (!looksLikePercent) {
              try {
                const stored = JSON.parse(localStorage.getItem('irrValues') || '[]');
                const entry = stored[i];
                if (entry && typeof entry === 'object') {
                  if (entry.raw && /%/.test(String(entry.raw))) looksLikePercent = true;
                  if (entry.label && /irr/i.test(String(entry.label))) looksLikePercent = true;
                  if (entry.irr && /%/.test(String(entry.irr))) looksLikePercent = true;
                }
              } catch (e) { /* ignore storage parse errors */ }
            }
            const numMatch = String(raw).match(/([0-9]+(?:\.[0-9]+)?)/);
            if (numMatch) {
              // Skip percent-like tokens from pairing; they should not be matched to USD components
              if (!looksLikePercent) {
                // infer unit: try stored entry's unit if present, else 'number'
                let valUnit = 'number';
                try {
                  const stored = JSON.parse(localStorage.getItem('irrValues') || '[]');
                  const e = stored[i]; if (e && e.unit) valUnit = e.unit;
                } catch (e) { /* ignore */ }
                numericValues.push({ idx: i, value: Number(numMatch[1]), unit: valUnit });
              }
            }
          });
          const compList = comps.map((c,ci) => Object.assign({ compIndex: ci, _used: false }, c)).filter(c => c && !isNaN(c.value) && c.type === 'component');
          if (!numericValues.length || !compList.length) return map;
          // Build all pairs
          const pairs = [];
          for (const v of numericValues) {
            for (const c of compList) {
              // require unit agreement for pairing: prefer unit-equal matches
              const compUnit = c.unit || 'usd';
              const valUnit = v.unit || 'number';
              // Skip pairing percent-like values (we filtered those out before) but enforce unit equality for safety
              if (valUnit && compUnit && valUnit !== 'number' && compUnit !== 'unknown' && valUnit !== compUnit) continue;
              const diff = Math.abs(Number(c.value) - v.value);
              pairs.push({ vIdx: v.idx, comp: c, diff, compUnit, valUnit });
            }
          }
          // Sort pairs by smallest difference first
          pairs.sort((a,b) => a.diff - b.diff);
          const usedVals = new Set();
          const usedComps = new Set();
          const ABS_THRESHOLD = 0.5;
          // Greedily assign best available pairs
          for (const p of pairs) {
            if (usedVals.has(p.vIdx) || usedComps.has(p.comp.compIndex)) continue;
            // Accept only if within absolute threshold or within 5% relative threshold
            const relThreshold = Math.abs(p.comp.value) * 0.05;
            if (p.diff <= ABS_THRESHOLD || p.diff <= relThreshold) {
              map[p.vIdx] = p.comp;
              usedVals.add(p.vIdx);
              usedComps.add(p.comp.compIndex);
            }
          }
        } catch (e) { /* ignore pairing failures */ }
        return map;
      })(irrData, pbComponents);
      // helper: given a raw value (string or number), find a matching component label from pbComponents
      // Return a matched object for a numeric value: {label,type,plantId,plantName,material,isLowest}
  function getMatchedLabelForValue(rawValue, valueIndex) {
        // helper: sanitize labels coming from assistant prose while preserving original
        function sanitizeLabel(raw) {
          if (!raw && raw !== 0) return '';
          let s = String(raw || '').trim();
          // remove common leading filler words
          s = s.replace(/^\s*(and|the|for)\b[:\s-]*/i, '');
          // remove trailing filler like 'is', 'are', 'at', 'of'
          s = s.replace(/\b(is|are|at|of)\b[\s:]*/ig, '');
          // collapse multiple spaces and punctuation
          s = s.replace(/[\(\)\:\.\,]+/g, ' ').replace(/\s+/g, ' ').trim();
          // canonicalize common component words conservatively
          const low = s.toLowerCase();
          if (/vendor/.test(low)) return 'Vendor Price';
          if (/production/.test(low) || /productions? cost/.test(low)) return 'Production Cost';
          if (/transport/.test(low)) return 'Transport Cost';
          if (/holding/.test(low)) return 'Holding Cost';
          // fallback: title-case the cleaned string
          return s.split(' ').map(w => w.charAt(0).toUpperCase() + w.slice(1)).join(' ');
        }

        function cloneAndSanitize(obj) {
          if (!obj) return null;
          const out = Object.assign({}, obj);
          out.originalLabel = out.label;
          out.label = sanitizeLabel(out.label || String(out.value || ''));
          return out;
        }
        // rawValue may contain appended text (e.g. '6.60PL02 Silvassa...') — extract first numeric token
        if (rawValue === null || rawValue === undefined) return null;
        const str = String(rawValue).trim();
        const numMatch = str.match(/([0-9]+(?:\.[0-9]+)?)/);
        if (!numMatch) return null;
          const num = parseFloat(numMatch[1]);
          const EPS = 1e-6;
        if (isNaN(num)) return null;
        // Heuristic: detect if the raw token looks like a percentage (contains '%')
        // Also, if a valueIndex is provided, inspect the stored irrValues entry to see if it was a labeled IRR (e.g. entry.label contains 'IRR' or entry.raw contains '%')
        const rawStr = String(rawValue);
        let looksLikePercent = /%/.test(rawStr);
        if (!looksLikePercent && typeof valueIndex === 'number') {
          try {
            const stored = JSON.parse(localStorage.getItem('irrValues') || '[]');
            const entry = stored[valueIndex];
            if (entry && typeof entry === 'object') {
              if (entry.raw && /%/.test(String(entry.raw))) looksLikePercent = true;
              if (entry.label && /irr/i.test(String(entry.label))) looksLikePercent = true;
              if (entry.irr && /%/.test(String(entry.irr))) looksLikePercent = true;
            }
          } catch (e) { /* ignore storage parse errors */ }
        }
        // Determine token unit from storage if available (percent/number)
        let tokenUnit = 'number';
        try {
          const stored = JSON.parse(localStorage.getItem('irrValues') || '[]');
          const entry = stored[valueIndex];
          if (entry && entry.unit) tokenUnit = entry.unit;
          // fallback: if raw contains '%' mark as percent
          if (entry && entry.raw && /%/.test(String(entry.raw))) tokenUnit = 'percent';
        } catch (e) { /* ignore */ }

        // Strong override: if any component was parsed with source:'paired' and its
        // numeric value exactly matches this token, prefer it immediately. This
        // prevents duplicates (e.g. PL02 production copies) from taking precedence
        // over explicit assistant-parsed pairs.
        try {
          const pairedExact = pbComponents.filter(pc => pc.type === 'component' && pc.source === 'paired' && !isNaN(pc.value) && Math.abs(Number(pc.value) - num) < EPS);
          if (pairedExact && pairedExact.length) {
            // prefer vendor -> production -> any paired; tiebreak by pairedCount
            const vendor = pairedExact.find(c => c.label && /vendor/i.test(String(c.label)));
            const production = pairedExact.find(c => c.label && /production/i.test(String(c.label)));
            const chooseList = vendor ? [vendor] : (production ? [production] : pairedExact.slice());
            chooseList.sort((a,b) => {
              const keyA = `${a.material}||${(a.plantId||a.plantName||'').trim()}`;
              const keyB = `${b.material}||${(b.plantId||b.plantName||'').trim()}`;
              return (pairedCountByPlantMaterial[keyB] || 0) - (pairedCountByPlantMaterial[keyA] || 0);
            });
            return cloneAndSanitize(chooseList[0]);
          }
        } catch (e) { /* ignore paired override failures */ }

        // If we have a precomputed mapping for this value index, prefer it,
        // but first check for exact total matches and prefer totals (plant totals)
        // over anonymous component mappings. Also prefer paired-origin components
        // when present.
        if (typeof valueIndex === 'number' && valueToComponentMap[valueIndex]) {
          const mapped = valueToComponentMap[valueIndex];
          try {
            // Prefer mapped/paired/component candidates first. Only if none of
            // these are present should we fall back to returning an exact total.
            // If mapped component was derived from pairing, prefer it
            if (mapped && mapped.source === 'paired') return cloneAndSanitize(mapped);
            // Try to find any paired components with same numeric value. If there
            // are multiple, pick the one from the plant that has the most paired
            // evidence for this material (conservative tie-breaker).
            const pairedSameCandidates = pbComponents.filter(pc => pc.type === 'component' && pc.source === 'paired' && !isNaN(pc.value) && Math.abs(Number(pc.value) - num) < EPS);
            if (pairedSameCandidates && pairedSameCandidates.length) {
              const best = pairedSameCandidates.slice().sort((a,b) => {
                const keyA = `${a.material}||${(a.plantId||a.plantName||'').trim()}`;
                const keyB = `${b.material}||${(b.plantId||b.plantName||'').trim()}`;
                const scoreA = pairedCountByPlantMaterial[keyA] || 0;
                const scoreB = pairedCountByPlantMaterial[keyB] || 0;
                if (scoreB !== scoreA) return scoreB - scoreA;
                return 0;
              })[0];
              if (best) return cloneAndSanitize(best);
            }
          } catch (e) { /* ignore and fallthrough to mapped fallback */ }
          if (mapped) {
            try {
              // Look for any component candidates (across all plants) that match this numeric value.
              const compCandidatesAll = pbComponents.filter(pc => pc.type === 'component' && !isNaN(pc.value) && Math.abs(Number(pc.value) - num) < EPS);
              if (compCandidatesAll && compCandidatesAll.length) {
                // Prefer a 'Vendor Price' candidate if present (even if plantId is blank)
                // Tolerant vendor match: match 'vendor' anywhere in the label (covers "And Vendor Price Is" etc.)
                const vendor = compCandidatesAll.find(c => c.label && /vendor/i.test(String(c.label)));
                if (vendor) return cloneAndSanitize(vendor);
                // If there are candidates with preferred labels, prefer the plant-less/global one
                const preferredLabels = ['production cost','vendor price','production','vendor'];
                for (const plab of preferredLabels) {
                  const matches = compCandidatesAll.filter(c => c.label && String(c.label).toLowerCase().trim() === plab);
                  if (matches.length) {
                    // prefer global/plant-less candidate if available
                    const global = matches.find(m => !(m.plantId || m.plantName));
                    if (global) return cloneAndSanitize(global);
                    // otherwise return any exact label match
                    return cloneAndSanitize(matches[0]);
                  }
                }
                // Prefer any paired-sourced candidate, break ties by paired-count
                const pairedCands = compCandidatesAll.filter(c => c.source === 'paired');
                if (pairedCands.length) {
                  const best = pairedCands.slice().sort((a,b) => {
                    const keyA = `${a.material}||${(a.plantId||a.plantName||'').trim()}`;
                    const keyB = `${b.material}||${(b.plantId||b.plantName||'').trim()}`;
                    return (pairedCountByPlantMaterial[keyB] || 0) - (pairedCountByPlantMaterial[keyA] || 0);
                  })[0];
                  if (best) return cloneAndSanitize(best);
                }
              }
            } catch (e) { /* ignore */ }
            return cloneAndSanitize(mapped);
          }
        }
        const candidates = [];
        // numeric epsilon matches (tolerant to small float issues) and two-decimal rounding
        const target2 = Number(num).toFixed(2);
        const percentMonetaryCandidates = [];
        for (const pc of pbComponents) {
          const compUnit = pc.unit || 'usd';
          // If both units are known and incompatible, skip
          if (tokenUnit !== 'number' && compUnit !== 'unknown' && tokenUnit !== compUnit) continue;
          // Normal case: units compatible or token is numeric
          if (!isNaN(pc.value) && Math.abs(pc.value - num) < EPS) {
            if (tokenUnit === 'percent' && compUnit === 'usd') {
              // candidate where percent token numerically equals a monetary component
              percentMonetaryCandidates.push(pc);
            } else {
              candidates.push(pc);
            }
          } else if (!isNaN(pc.value) && Number(pc.value).toFixed(2) === target2) {
            if (tokenUnit === 'percent' && compUnit === 'usd') {
              percentMonetaryCandidates.push(pc);
            } else {
              candidates.push(pc);
            }
          }
        }
        // If we didn't find standard candidates but there are percent->monetary numeric matches,
        // allow them only when we have additional evidence: paired source or label hints in stored irr entry
        if (!candidates.length && percentMonetaryCandidates.length) {
          try {
            const stored = JSON.parse(localStorage.getItem('irrValues') || '[]');
            const entry = stored[valueIndex] || {};
            const labelHints = ['vendor','production','transport','holding','price','cost'];
            const entryStr = (entry && (entry.label || entry.raw || entry.irr)) ? String(entry.label || entry.raw || entry.irr).toLowerCase() : '';
            // prefer paired-origin candidates first
            const pairedFirst = percentMonetaryCandidates.sort((a,b) => ((b.source === 'paired') - (a.source === 'paired')));
            // accept a candidate if it was paired, or if stored entry contains a monetary hint
            const accepted = pairedFirst.filter(c => (c && c.source === 'paired') || labelHints.some(h => entryStr.includes(h)));
                if (accepted.length) candidates.push(...accepted);
          } catch (e) { /* ignore */ }
        }
        // fallback to formatted string comparison
        if (!candidates.length) {
          const s2 = Number(num).toFixed(2);
          const s4 = Number(num).toFixed(4);
          for (const pc of pbComponents) {
            const pstr = String(pc.value);
            if (pstr === s2 || pstr === s4 || pstr === Number(pc.value).toFixed(2) || pstr === Number(pc.value).toFixed(4)) candidates.push(pc);
          }
        }
        // If we have candidates from exact/two-decimal/formatted checks, use them
        if (candidates.length) {
          // Prefer named components when available (use canonical forms)
          const preferred = ["Vendor Price","Production Cost","Transport Cost","Holding Cost"];
          // Prefer candidates that match token unit first
          const unitMatched = candidates.filter(c => ((c.unit || 'usd') === tokenUnit));
          // If any candidates were discovered by the widget pairing logic ('paired'), prefer them first
          const pairedPrefer = (arr) => {
            const paired = arr.filter(x => x && x.source === 'paired');
            if (paired.length) return paired.concat(arr.filter(x => x && x.source !== 'paired'));
            return arr;
          };
          const unitMatchedOrdered = pairedPrefer(unitMatched.length ? unitMatched : candidates);
          for (const pref of preferred) {
            const found = unitMatchedOrdered.find(c => c && c.label && c.label.toLowerCase() === pref.toLowerCase());
            if (found) return Object.assign({}, found);
          }
          const fallbackPreferred = ["vendor","production","transport","holding"];
          for (const fp of fallbackPreferred) {
            const found = unitMatchedOrdered.find(c => c && c.label && c.label.toLowerCase().includes(fp));
            if (found) return Object.assign({}, found);
          }
            const comp = candidates.find(c => c.type === 'component');
          if (comp) return cloneAndSanitize(comp);
          const tot = cloneAndSanitize(candidates[0]);
          if (tot && tot.type === 'total') {
            tot.isLowest = (typeof lowestTotalByMaterial[tot.material] !== 'undefined' && Math.abs(tot.value - lowestTotalByMaterial[tot.material]) < EPS);
          }
          return tot;
        }
        // Nearest-neighbor fallback: consider all pbComponents and pick the closest value
        if (pbComponents.length) {
          let best = null;
          let bestDiff = Infinity;
          for (const pc of pbComponents) {
            if (isNaN(pc.value)) continue;
            const diff = Math.abs(Number(pc.value) - num);
            if (diff < bestDiff) { bestDiff = diff; best = pc; }
          }
              if (best) {
            // Accept if difference within absolute 0.25 or within 5% relative
            const absThreshold = 0.25;
            const relThreshold = Math.abs(num) * 0.05;
            if (bestDiff <= absThreshold || bestDiff <= relThreshold) {
              return cloneAndSanitize(best);
            }
          }
        }
        return null;
      }

      // Developer diagnostic: dump candidate matches and scoring for each Value N
      function dumpMatchDiagnostics(irrData) {
        try {
          const out = [];
          const pbList = JSON.parse(localStorage.getItem('priceBreakdowns') || '[]');
          out.push('Parsed priceBreakdowns: ' + JSON.stringify(pbList, null, 2));
          out.push('Flattened pbComponents: ' + JSON.stringify(pbComponents, null, 2));
          (irrData || JSON.parse(localStorage.getItem('irrValues') || '[]')).forEach((d, i) => {
            const raw = (typeof d === 'object' && d !== null) ? d.irr : d;
            out.push(`--- Value ${i+1}: raw='${raw}'`);
            const numMatch = String(raw).match(/([0-9]+(?:\.[0-9]+)?)/);
            const num = numMatch ? Number(numMatch[1]) : null;
            out.push(' numeric token: ' + String(num));
            const candidates = pbComponents.filter(pc => !isNaN(pc.value) && Math.abs(Number(pc.value) - (num || 0)) < 1e-6);
            out.push(' candidates: ' + JSON.stringify(candidates, null, 2));
            const matched = getMatchedLabelForValue(raw, i);
            out.push(' chosen match: ' + JSON.stringify(matched, null, 2));
          });
          document.getElementById('devMatchOutput').textContent = out.join('\n\n');
          console.debug('Dump Matches:', out.join('\n\n'));
        } catch (e) { console.error('dumpMatchDiagnostics error', e); }
      }

      // Wire up dev panel toggle and Dump Matches button
      document.addEventListener('keydown', (e) => {
        if (e.key === 'D' || e.key === 'd') {
          const p = document.getElementById('devMatchPanel');
          if (p.style.display === 'none' || !p.style.display) p.style.display = 'block'; else p.style.display = 'none';
        }
      });
      document.getElementById('dumpMatchesBtn').addEventListener('click', () => dumpMatchDiagnostics());
      document.getElementById('closeDevPanel').addEventListener('click', () => { document.getElementById('devMatchPanel').style.display = 'none'; });

      irrMetricCards.innerHTML = irrData.map((d, i) => {
        let rawValue = (typeof d === 'object' && d !== null) ? d.irr : d;
        let num = parseFloat(rawValue);
        // Determine token unit: prefer explicit unit on the irrData entry
        const tokenUnit = (typeof d === 'object' && d !== null && d.unit) ? d.unit : (String(rawValue).includes('%') ? 'percent' : 'number');
        // Compute label: for percent tokens show only the numeric percent (remove generic 'Value N')
        let label;
        if (typeof d === 'object' && d !== null) {
          if (d.year) label = `Year ${d.year}`;
          else if (d.label) label = d.label;
          else if (tokenUnit === 'percent') label = !isNaN(num) ? (Number(num).toFixed(4) + '%') : `Value ${i+1}`;
          else label = `Value ${i+1}`;
        } else {
          label = tokenUnit === 'percent' ? (!isNaN(num) ? (Number(num).toFixed(4) + '%') : `Value ${i+1}`) : `Value ${i+1}`;
        }
        // If a matched component comes from a paired parse, prefer it as the primary label
        // for non-percent tokens. This makes assistant-provided labels (e.g., 'Vendor Price')
        // replace noisy stored labels like 'Production Cost' when appropriate.
        if (tokenUnit !== 'percent') {
          const forcedMatch = typeof getMatchedLabelForValue === 'function' ? getMatchedLabelForValue((typeof d === 'object' && d !== null) ? d.irr : d, i) : null;
          if (forcedMatch && forcedMatch.source === 'paired' && forcedMatch.label) {
            label = forcedMatch.label;
          }
        }
        // Only show the trend icon for percent/IRR tokens. Hide for monetary/component values.
        let icon = tokenUnit === 'percent' ? '<span class="metric-icon">📈</span>' : '';
        const matched = getMatchedLabelForValue(rawValue);
        // Determine if the existing label is generic: Value N, empty, or numeric-only
        const isGenericLabel = (/^Value \d+$/.test(label)) || label.trim() === '' || (/^[0-9]+(?:\.[0-9]+)?$/.test(String(label).trim()));
        const rawHasExtra = String(rawValue).trim().match(/^[0-9]+(?:\.[0-9]+)?\s*$/) ? false : true;

        // If token is percent, always show only the percent value and do not attach matched labels
        if (tokenUnit === 'percent') {
          const displayVal = (!isNaN(num) ? Number(num).toFixed(4) + '%' : String(rawValue));
          return `<div class="metric-card animate-fadein">${icon}<div><div>${escapeHtml(displayVal)}</div></div></div>`;
        }

        if (matched && (isGenericLabel || rawHasExtra)) {
          // Prefer component label formatting with explicit numeric value
          if (matched.type === 'component') {
            const displayVal = (!isNaN(num) ? Number(num).toFixed(2) : (matched.value !== undefined ? Number(matched.value).toFixed(2) : String(rawValue)));
            label = `${matched.label}`;
            // For monetary components, don't show the percent/trend icon; show value and small label
            return `<div class="metric-card animate-fadein">${icon}<div><div>${escapeHtml(label)}</div><div><span class="font-mono">$${displayVal}</span></div><div class="text-xs text-slate-300">${escapeHtml(matched.label || '')}</div></div></div>`;
          }
          // For totals, show plant name/ID and annotate lowest
          if (matched.type === 'total') {
            const plantTitle = `${matched.plantName || matched.plantId || ''}`.trim();
            const displayVal = (!isNaN(num) ? Number(num).toFixed(2) : (matched.value !== undefined ? Number(matched.value).toFixed(2) : String(rawValue)));
            label = `${plantTitle}${matched.isLowest ? ' (Lowest)' : ''}`;
            // render as: Plant Title / $value / small subtext (plant id/name)
            return `<div class="metric-card animate-fadein">${icon}<div><div>${escapeHtml(label)}</div><div><span class="font-mono">$${displayVal}</span></div><div class="text-xs text-slate-300">${escapeHtml(plantTitle)}</div></div></div>`;
          }
        }

        // If matched but original label was not generic, append small matched info beneath (only for non-percent tokens)
        if (matched) {
          const extra = matched.type === 'total' ? `${matched.plantId || ''} ${matched.plantName || ''}`.trim() : matched.label;
          return `<div class="metric-card animate-fadein">${icon}<div><div>${escapeHtml(label)}</div><div>${escapeHtml(String(rawValue))}${extra ? `<div class="text-xs text-slate-300">${escapeHtml(extra)}</div>` : ''}</div></div></div>`;
        }

        return `<div class="metric-card animate-fadein">${icon}<div><div>${escapeHtml(label)}</div><div>${escapeHtml(String(rawValue))}</div></div></div>`;
      }).join('');

      // Extra Metrics as cards
      const validIrrs = irrData.map(d => (typeof d === 'object' && d !== null) ? parseFloat(d.irr) : parseFloat(d)).filter(n => !isNaN(n));
      const avg = validIrrs.length ? (validIrrs.reduce((a,b)=>a+b,0)/validIrrs.length).toFixed(4) : '-';
      const max = validIrrs.length ? Math.max(...validIrrs).toFixed(4) : '-';
      const min = validIrrs.length ? Math.min(...validIrrs).toFixed(4) : '-';
      let growth = '-';
      if (validIrrs.length > 1) {
        const first = validIrrs[0], last = validIrrs[validIrrs.length-1];
        growth = (((last-first)/Math.abs(first))*100).toFixed(2) + '%';
      }
      document.getElementById('extraMetricCards').innerHTML = `
        <div class="metric-card animate-fadein"><span class="metric-icon">🧮</span>Average Rate: <span class="text-yellow-300">${avg !== '-' ? avg + '%' : '-'}</span></div>
        <div class="metric-card animate-fadein"><span class="metric-icon">🚀</span>Highest Rate: <span class="text-green-300">${max !== '-' ? max + '%' : '-'}</span></div>
        <div class="metric-card animate-fadein"><span class="metric-icon">📉</span>Lowest Rate: <span class="text-red-300">${min !== '-' ? min + '%' : '-'}</span></div>
        <div class="metric-card animate-fadein"><span class="metric-icon">📊</span>Growth Rate: <span class="text-blue-300">${growth}</span></div>
      `;

      // Sortable summary table
      const labels = irrData.map((d, i) => {
        if (typeof d === 'object' && d !== null) {
          if (d.year) return `Year ${d.year}`;
          if (d.label) return d.label;
          return `Value ${i+1}`;
        } else {
          return `Value ${i+1}`;
        }
      });
      const tbody = document.getElementById('irrTable').querySelector('tbody');
      tbody.innerHTML = '';
      // Build table rows from irrData. Prefer matched labels for generic Value N entries.
      const rows = [];
      irrData.forEach((d, i) => {
        let value = (typeof d === 'object' && d !== null) ? d.irr : d;
        let label = labels[i];
        // Determine token unit (prefer explicit unit on stored entry)
        const tokenUnit = (typeof d === 'object' && d !== null && d.unit) ? d.unit : (String(value).includes('%') ? 'percent' : 'number');
        const matchedObj = typeof getMatchedLabelForValue === 'function' ? getMatchedLabelForValue(value, i) : null;
        // Only replace generic Value N labels with matched names for non-percent tokens
        if (matchedObj && /^Value \d+$/.test(label) && tokenUnit !== 'percent') {
          if (matchedObj.type === 'component') {
            const numVal = parseFloat(String(value).match(/([0-9]+(?:\.[0-9]+)?)/)?.[1] || value);
            label = `${matchedObj.label} ($${Number(numVal).toFixed(2)})`;
          } else if (matchedObj.type === 'total') {
            const numVal = parseFloat(String(value).match(/([0-9]+(?:\.[0-9]+)?)/)?.[1] || value);
            const plantTitle = `${matchedObj.plantName || ''} (${matchedObj.plantId || ''})`.trim();
            label = `${plantTitle} has a total cost of $${Number(numVal).toFixed(2)}` + (matchedObj.isLowest ? ' (Lowest)' : '');
          }
        }
        // If original label was not generic but matchedObj is paired, prefer matchedObj label
        if (tokenUnit !== 'percent' && matchedObj && matchedObj.source === 'paired') {
          if (matchedObj.type === 'component') {
            const numVal = parseFloat(String(value).match(/([0-9]+(?:\.[0-9]+)?)/)?.[1] || value);
            label = `${matchedObj.label} ($${Number(numVal).toFixed(2)})`;
          }
        }
        // Format display value: percent tokens get 4-decimal percent formatting; others that look like money get currency
        const numericToken = String(value).match(/([0-9]+(?:\.[0-9]+)?)/)?.[1];
        const isMoney = numericToken !== undefined && tokenUnit !== 'percent';
        const displayNum = tokenUnit === 'percent' ? (numericToken ? (Number(numericToken).toFixed(4) + '%') : escapeHtml(String(value))) : (isMoney ? `$${Number(numericToken).toFixed(2)}` : escapeHtml(String(value)));
        // include small extra line showing matched label/plant if available, but suppress for percent tokens
        const mapped = typeof getMatchedLabelForValue === 'function' ? getMatchedLabelForValue(value, i) : null;
        const extraLine = (mapped && tokenUnit !== 'percent') ? `<div class="text-xs text-slate-300">${escapeHtml(mapped.type === 'total' ? `${mapped.plantName || mapped.plantId}` : mapped.label)}</div>` : '';
        rows.push(`<tr><td class="border border-white/20 px-4 py-2">${escapeHtml(label)}</td><td class="border border-white/20 px-4 py-2">${displayNum}${extraLine}</td></tr>`);
      });
      tbody.innerHTML = rows.join('');
      // Last Updated Timestamp
      const lastUpdatedEl = document.getElementById('lastUpdated');
      const now = new Date();
      lastUpdatedEl.textContent = `Last Updated: ${now.toLocaleString()}`;

      // Bar Chart (replaces previous Radar chart)
      if(radarChart) radarChart.destroy();
      radarChart = new Chart(document.getElementById('irrRadarChart'), {
        type: 'bar',
        data: {
          labels,
          datasets: [{
            label: 'Value (%)',
            data: labels.map((_, i) => {
              let value = (typeof irrData[i] === 'object' && irrData[i] !== null) ? irrData[i].irr : irrData[i];
              let num = parseFloat(value);
              return (value !== null && value !== undefined && !isNaN(num)) ? num : 0;
            }),
            backgroundColor: colors,
            borderColor: '#60a5fa',
            borderWidth: 1
          }]
        },
        options: {
          plugins: { legend: { labels: { color: '#e6eef8' } } },
          scales: {
            x: { ticks: { color: '#e6eef8' }, grid: { color: '#334155' } },
            y: { ticks: { color: '#e6eef8' }, grid: { color: '#334155' }, beginAtZero: true }
          }
        }
      });

      // Line Chart
      if(lineChart) lineChart.destroy();
      lineChart = new Chart(document.getElementById('irrLineChart'), {
        type: 'line',
        data: {
          labels,
          datasets: [{
            label: 'Value (%)',
            data: labels.map((_, i) => {
              let value = (typeof irrData[i] === 'object' && irrData[i] !== null) ? irrData[i].irr : irrData[i];
              let num = parseFloat(value);
              return (value !== null && value !== undefined && !isNaN(num)) ? num : 0;
            }),
            fill: false,
            borderColor: '#34d399',
            backgroundColor: 'rgba(52,211,153,0.2)',
            tension: 0.3,
            pointBackgroundColor: colors,
            pointBorderColor: '#fff',
            borderWidth: 2
          }]
        },
        options: {
          plugins: { legend: { labels: { color: '#e6eef8' } } },
          scales: {
            x: { ticks: { color: '#e6eef8' }, grid: { color: '#334155' } },
            y: { ticks: { color: '#e6eef8' }, grid: { color: '#334155' }, beginAtZero: true }
          }
        }
      });

      // Donut Chart - use numeric values as labels so legend shows actual numbers
      if(donutChart) donutChart.destroy();
      // compute numeric dataset and formatted labels (e.g. "12.3456%")
      const donutNums = labels.map((_, i) => {
        let value = (typeof irrData[i] === 'object' && irrData[i] !== null) ? irrData[i].irr : irrData[i];
        let num = parseFloat(value);
        return (value !== null && value !== undefined && !isNaN(num)) ? num : 0;
      });
      const donutLabels = donutNums.map(n => isNaN(n) ? '0' : (Number(n).toFixed(4) + '%'));
      donutChart = new Chart(document.getElementById('irrDonutChart'), {
        type: 'doughnut',
        data: {
          labels: donutLabels,
          datasets: [{
            label: 'Value (%)',
            data: donutNums,
            backgroundColor: colors,
            borderColor: '#fff',
            borderWidth: 2
          }]
        },
        options: {
          plugins: { legend: { labels: { color: '#e6eef8' } } }
        }
      });

      
    }

    // Assume irrValues is loaded from localStorage
    function renderIRRValues() {
      const irrValues = JSON.parse(localStorage.getItem('irrValues') || '[]');
      const container = document.getElementById('irr-list');
      if (!container) return;
      container.innerHTML = '';
      let count = 1;
      irrValues.forEach(v => {
        let label = '';
        if (v.year) {
          label = `Year ${v.year}: ${v.irr}%`;
        } else if (v.label) {
          label = `${v.label}: ${v.irr}%`;
        } else {
          label = `Value ${count}: ${v.irr}%`;
          count++;
        }
        const div = document.createElement('div');
        div.textContent = label;
        container.appendChild(div);
      });
    }

  // On load, try to read IRR data from localStorage
  let irrDataReceived = false;
  let currentSort = { col: null, asc: true };
  function updateDashboardFromStorage() {
    const storedIrr = localStorage.getItem('irrValues');
    if (storedIrr) {
      try {
        const irrArray = JSON.parse(storedIrr);
        if (Array.isArray(irrArray) && irrArray.length) {
          irrDataReceived = true;
          renderDashboard(irrArray);
          // price breakdown rendering removed; keep mappings rendered
          renderValueMappings(irrArray);
        }
      } catch(e) { console.error('Failed to parse IRR data from localStorage', e); }
    }
    if (!irrDataReceived) {
      document.getElementById('irrMetricCards').innerHTML = '<div class="metric-card">Waiting for IRR data...</div>';
      document.getElementById('extraMetricCards').innerHTML = '';
      const ctx = document.getElementById('irrRadarChart').getContext('2d');
      ctx.clearRect(0,0,400,200);
    }
  }
  updateDashboardFromStorage();
  // Listen for localStorage changes (auto-update dashboard)
  window.addEventListener('storage', function(event) {
    if (event.key === 'irrValues') {
      updateDashboardFromStorage();
    }
    if (event.key === 'priceBreakdowns') {
      // Re-render so new components are available for mapping
      updateDashboardFromStorage();
    }
  });

    // Also accept direct postMessage updates from the widget (more dynamic than polling storage)
    window.addEventListener('message', (evt) => {
      if (!evt.data) return;
      try {
        if (evt.data.type === 'priceBreakdowns' && evt.data.data) {
          // Persist incoming price breakdowns so matching logic has the latest components
          try { localStorage.setItem('priceBreakdowns', JSON.stringify(evt.data.data)); } catch (e) { console.error('Failed to save priceBreakdowns', e); }
          // Re-run full dashboard render so pbComponents are recomputed and mappings apply
          updateDashboardFromStorage();
        }
        if (evt.data.type === 'irrData' && evt.data.data) {
          try { localStorage.setItem('irrValues', JSON.stringify(evt.data.data)); } catch (e) {}
          updateDashboardFromStorage();
        }
      } catch (e) { console.error('message handling error', e); }
    });
  // Sort table columns
  document.addEventListener('DOMContentLoaded', () => {
    document.getElementById('sortLabel').addEventListener('click', () => {
      sortTable('label');
    });
    document.getElementById('sortIRR').addEventListener('click', () => {
      sortTable('irr');
    });
  });
  function sortTable(col) {
    const storedIrr = localStorage.getItem('irrValues');
    if (!storedIrr) return;
    let irrArray = JSON.parse(storedIrr);
    if (col === currentSort.col) currentSort.asc = !currentSort.asc;
    else currentSort = { col, asc: true };
    irrArray.sort((a, b) => {
      if (col === 'label') {
        const labelA = a.year ? `Year ${a.year}` : (a.label || '');
        const labelB = b.year ? `Year ${b.year}` : (b.label || '');
        return currentSort.asc ? labelA.localeCompare(labelB) : labelB.localeCompare(labelA);
      } else if (col === 'irr') {
        const numA = parseFloat(a.irr);
        const numB = parseFloat(b.irr);
        return currentSort.asc ? numA - numB : numB - numA;
      }
      return 0;
    });
    renderDashboard(irrArray);
  }
  </script>
</body>
</html>
